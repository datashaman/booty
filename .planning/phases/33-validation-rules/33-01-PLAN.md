---
phase: 33-validation-rules
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/architect/validation.py
  - src/booty/architect/__init__.py
  - tests/test_architect_validation.py
autonomous: true

must_haves:
  truths:
    - Architect validates steps ≤ 12 with id and action
    - Architect validates actions ∈ {read, add, edit, run, verify, research}
    - touch_paths equals union of step paths from read/edit/add/research
    - Empty paths for read/edit/add/research cause block; run/verify empty path accepted
    - Risk recomputed from touch_paths (HIGH/MEDIUM/LOW)
    - Architect overrides Planner risk_level when recomputed differs
  artifacts:
    - path: src/booty/architect/validation.py
      provides: validate_structural, validate_paths, compute_risk_from_touch_paths
    - path: tests/test_architect_validation.py
      provides: Unit tests for validation rules
  key_links:
    - from: src/booty/architect/validation.py
      to: booty.planner.schema
      via: Plan, Step imports
      pattern: "from booty.planner.schema import"
---

<objective>
Implement structural integrity and path consistency validation for Architect (ARCH-06, ARCH-07, ARCH-08, ARCH-09, ARCH-10, ARCH-11, ARCH-12).

Purpose: Architect must validate plan structure before approval. Rule-driven only; no LLM.

Output: validation.py with validate_structural, validate_paths, compute_risk_from_touch_paths; unit tests.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-validation-rules/33-CONTEXT.md
@.planning/phases/33-validation-rules/33-RESEARCH.md
@src/booty/planner/schema.py
@src/booty/planner/generation.py
@src/booty/architect/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Structural validation</name>
  <files>src/booty/architect/validation.py</files>
  <action>
Create src/booty/architect/validation.py with:

1. VALID_ACTIONS = frozenset({"read", "add", "edit", "run", "verify", "research"})
2. validate_structural(plan: Plan) -> ValidationResult (dataclass or simple class with passed: bool, errors: list[str], blocks: bool)
   - steps length ≤ 12 (ARCH-06); if > 12, blocks
   - each step has id and action (ARCH-07); missing either blocks
   - each action ∈ VALID_ACTIONS (ARCH-08); invalid action blocks
3. Return ValidationResult with blocks=True for any structural failure.

Reuse Plan/Step from booty.planner.schema. Handle plan as Plan or dict: normalize to Plan via Plan.model_validate() when dict; catch ValidationError and return blocked result.
  </action>
  <verify>pytest tests/test_architect_validation.py -k "structural" -v</verify>
  <done>validate_structural rejects >12 steps, missing id/action, invalid action; accepts valid plans</done>
</task>

<task type="auto">
  <name>Task 2: Path consistency and empty path rules</name>
  <files>src/booty/architect/validation.py</files>
  <action>
Add to validation.py:

1. derive_touch_paths(plan: Plan) -> list[str]
   - Union of step.path for steps where action ∈ {read, edit, add, research} and path is non-none and non-empty
   - Strip leading slash, normalize, return sorted unique
   - Mirror planner/generation.py logic but include "research" (ARCH-08)

2. validate_paths(plan: Plan) -> ValidationResult
   - expected = derive_touch_paths(plan)
   - If plan.touch_paths != expected (as sets): flag mismatch, add to architect_notes, do NOT block (we will fix in worker)
   - Empty path rules (per CONTEXT):
     - read/add/edit/research with no path: BLOCK
     - run/verify with path: path ignored, valid
     - All run/verify (touch_paths empty): FLAG in architect_notes, approve
   - Return ValidationResult with blocks=True only for read/add/edit/research with empty path
  </action>
  <verify>pytest tests/test_architect_validation.py -k "path" -v</verify>
  <done>derive_touch_paths matches Planner union logic; empty path blocks for read/edit/add/research; run/verify without path accepted</done>
</task>

<task type="auto">
  <name>Task 3: Risk recomputation</name>
  <files>src/booty/architect/validation.py</files>
  <action>
Add to validation.py:

1. compute_risk_from_touch_paths(touch_paths: list[str]) -> Literal["LOW","MEDIUM","HIGH"]
   - HIGH: any path in .github/workflows/, infra/, migrations, or ends with package-lock.json, yarn.lock, uv.lock, poetry.lock, Cargo.lock
   - MEDIUM: pyproject.toml, package.json, requirements.txt, Cargo.toml (root or common manifest paths)
   - LOW: else
   - Take max severity across all paths

2. ensure_touch_paths_and_risk(plan: Plan) -> Plan
   - Recompute touch_paths = derive_touch_paths(plan)
   - Set plan.touch_paths = touch_paths (modify in place if mutable, or return new Plan)
   - risk = compute_risk_from_touch_paths(touch_paths)
   - If plan.risk_level != risk: override plan.risk_level = risk (ARCH-12)

Export ValidationResult, validate_structural, validate_paths, derive_touch_paths, compute_risk_from_touch_paths, ensure_touch_paths_and_risk from architect/__init__.py or validation.py.
  </action>
  <verify>pytest tests/test_architect_validation.py -v</verify>
  <done>Risk correctly classified; ensure_touch_paths_and_risk updates plan; override when Planner risk differs</done>
</task>

</tasks>

<verification>
- All validation functions have unit tests
- No LLM calls in validation module
- Plan model used; dict normalized to Plan
</verification>

<success_criteria>
- ARCH-06, ARCH-07, ARCH-08, ARCH-09, ARCH-10, ARCH-11, ARCH-12 covered
- validation.py passes tests
- architect/__init__.py exports new symbols
</success_criteria>

<output>
After completion, create `.planning/phases/33-validation-rules/33-01-SUMMARY.md`
</output>
