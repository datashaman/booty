---
phase: 14-governor-foundation-persistence
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/verify-main.yml
  - src/booty/cli.py
autonomous: true

must_haves:
  truths:
    - "verify-main workflow runs on push to main"
    - "verify-main runs tests (setup, install, test from .booty.yml)"
    - "Reuses Verifier test execution logic (DRY)"
  artifacts:
    - path: .github/workflows/verify-main.yml
      provides: Verification on push to main
    - path: src/booty/cli.py
      provides: booty verify-run command (or similar)
  key_links:
    - from: verify-main.yml
      to: booty verify-run or test commands
      via: run step
      pattern: booty verify|pytest
---

<objective>
Create verify-main workflow that runs on push to main and executes tests.

Purpose: Success criteria 6 — "Verify-main workflow (runs on push to main, runs tests)". Reuse Verifier logic.

Output: .github/workflows/verify-main.yml, booty verify-run CLI.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-governor-foundation-persistence/14-CONTEXT.md
@.planning/phases/14-governor-foundation-persistence/14-RESEARCH.md
@src/booty/test_runner/executor.py
@src/booty/test_runner/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add booty verify-run command</name>
  <files>src/booty/cli.py</files>
  <action>
Add @verifier.command("run") or new top-level command verify-run. Signature: @click.option("--workspace", type=click.Path(exists=True, path_type=Path), default="."). Command: load_booty_config(workspace), run setup_command if present (subprocess.run), run install_command if present (subprocess.run), then run test_command via asyncio.run(execute_tests(config.test_command, config.timeout_seconds, workspace)). Use config from BootyConfig/BootyConfigV1. Exit with test exit code. This reuses execute_tests from test_runner.executor — the same code Verifier uses.
  </action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && booty verifier run 2>&1 | tail -3</verify>
  <done>booty verifier run executes tests using .booty.yml config</done>
</task>

<task type="auto">
  <name>Task 2: Create verify-main workflow</name>
  <files>.github/workflows/verify-main.yml</files>
  <action>
Create .github/workflows/verify-main.yml:
- name: Verify main
- on: push, branches: [main]
- jobs.verify: runs-on ubuntu-latest, steps: checkout, (optional: cache venv), run setup_command from .booty.yml (e.g. python3 -m venv .venv), run install_command (e.g. .venv/bin/pip install -e '.[dev]'), run booty verifier run --workspace . (or run test_command directly: .venv/bin/pytest). For simplicity: use the same steps as the project's test workflow if one exists, or mirror .booty.yml: setup_command, install_command, test_command. The booty verifier run loads .booty.yml and runs those — so we can just use "run: booty verifier run" after pip install -e . to get booty. The workflow needs booty installed first. So: checkout, (venv + pip install -e . from pyproject), then booty verifier run. That matches how CI would run.
  </action>
  <verify>test -f .github/workflows/verify-main.yml && grep -E "on:|push|main" .github/workflows/verify-main.yml</verify>
  <done>verify-main.yml runs on push to main and executes verification</done>
</task>

</tasks>

<verification>
- booty verifier run loads .booty.yml and runs setup/install/test
- verify-main workflow triggers on push to main
- Workflow completes with test result (pass/fail)
</verification>

<success_criteria>
- [ ] booty verifier run command exists
- [ ] .github/workflows/verify-main.yml exists
- [ ] Workflow runs tests on push to main
</success_criteria>

<output>
After completion, create `.planning/phases/14-governor-foundation-persistence/14-05-SUMMARY.md`
</output>
