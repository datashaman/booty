---
phase: 23-ingestion
plan: 03
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/booty/security/runner.py
  - src/booty/verifier/runner.py
autonomous: true

must_haves:
  truths:
    - "Security FAIL (secret, vuln, audit error): add_record(security_block) with metadata.trigger"
    - "Security ESCALATE (permission drift): add_record(security_block) with trigger=permission_drift"
    - "Verifier FAIL (import, compile, test, install): add_record(verifier_cluster) per failure class"
  artifacts:
    - path: src/booty/security/runner.py
      provides: Memory ingestion on FAIL and ESCALATE
      contains: add_record|build_security_block_record
    - path: src/booty/verifier/runner.py
      provides: Memory ingestion on Verifier failure
      contains: add_record|build_verifier_cluster_record
  key_links:
    - from: security runner
      to: memory.add_record
      via: build_security_block_record at each failure/escalate path
      pattern: add_record
    - from: verifier runner
      to: memory.add_record
      via: build_verifier_cluster_record at each failure path
      pattern: add_record
---

<objective>
Wire Security and Verifier agents into Memory. At each failure/ESCALATE path, build record and call add_record. Load booty_config from repo .booty.yml (runners already load config); apply memory env overrides.

Purpose: MEM-09, MEM-10, MEM-11 — security_block and verifier_cluster records stored.
Output: security/runner.py and verifier/runner.py call add_record at failure points.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-ingestion/23-CONTEXT.md
@.planning/phases/23-ingestion/23-RESEARCH.md
@src/booty/security/runner.py
@src/booty/verifier/runner.py
@src/booty/memory/adapters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Security FAIL and ESCALATE to Memory</name>
  <files>src/booty/security/runner.py</files>
  <action>
1. Add helper _ingest_security_record(job, trigger, title, summary, paths, repo, security_config) in runner:
   - Load booty_config: we have repo (get_verifier_repo). Get .booty.yml from repo.get_contents(".booty.yml", ref=job.head_sha). load_booty_config_from_content. mem_config = get_memory_config(booty_config); mem_config = apply_memory_env_overrides(mem_config) if mem_config else None
   - If mem_config and mem_config.enabled: try: record = build_security_block_record(job, trigger, title, summary, paths); add_record(record, mem_config); except: logger.warning("memory_ingestion_failed", type="security_block", error=str(e))
   - trigger: "secret" | "vulnerability" | "permission_drift"
   - paths: for FAIL use paths from findings or []; for ESCALATE use touched paths list

2. At each edit_check_run(conclusion="failure") in process_security_job:
   - Secret detected (result.findings): trigger="secret", paths=[f.get("path") for f in result.findings if f.get("path")]
   - Scan not ok (result.scan_ok False): trigger="secret" (error case)
   - Audit failed (not audit_result.ok): trigger="vulnerability", paths from audit_result.findings
   - Audit exception: trigger="vulnerability"
   - Generic exception: trigger="secret" (fallback)
   - Call _ingest_security_record after edit_check_run, before return

3. At ESCALATE path (sensitive_paths_touched, persist_override, conclusion="success"):
   - trigger="permission_drift", paths=touched
   - Call _ingest_security_record after persist_override, before return

Imports: from booty.memory import add_record, get_memory_config; from booty.memory.config import apply_memory_env_overrides; from booty.memory.adapters import build_security_block_record
  </action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -c "
from booty.security.runner import process_security_job
import inspect
src = inspect.getsource(process_security_job)
assert 'add_record' in src or 'build_security_block_record' in src
print('OK: Security wired to memory')
"</verify>
  <done>Security FAIL and ESCALATE produce security_block records in Memory</done>
</task>

<task type="auto">
  <name>Task 2: Wire Verifier FAIL to Memory</name>
  <files>src/booty/verifier/runner.py</files>
  <action>
1. Add helper _ingest_verifier_record(job, failure_type, paths, summary, config, repo):
   - config is BootyConfig from load_booty_config; booty_config = config
   - mem_config = get_memory_config(config) if config else None; mem_config = apply_memory_env_overrides(mem_config) if mem_config else None
   - If mem_config and mem_config.enabled: try: record = build_verifier_cluster_record(job, failure_type, paths, summary); add_record(record, mem_config); except: logger.warning(...)
   - repo from get_verifier_repo (we have it in process_verifier_job)

2. At each failure path, call _ingest_verifier_record BEFORE edit_check_run (so we have the failure context):
   - Install failed: failure_type="install", paths=[], summary from stderr
   - Import/compile: failure_type="import" or "compile" or "multiple" — CONTEXT says one record per class. So: if has_import and has_compile: call for "import" with import paths, call for "compile" with compile paths. If only import: one call "import". If only compile: one call "compile".
   - Test failed: failure_type="test", paths from py_files or changed files, summary from output_summary
   - Generic exception: failure_type="error", paths=[]

3. For import/compile: get paths from annotations — import_errors have path, compile_errors have path. paths = [a.get("path") for a in (import_errors + compile_errors) if a.get("path")] for each class separately.

Imports: from booty.memory import add_record, get_memory_config; from booty.memory.config import apply_memory_env_overrides; from booty.memory.adapters import build_verifier_cluster_record
  </action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -c "
from booty.verifier.runner import process_verifier_job
import inspect
src = inspect.getsource(process_verifier_job)
assert 'add_record' in src or 'build_verifier_cluster_record' in src
print('OK: Verifier wired to memory')
"</verify>
  <done>Verifier FAIL produces verifier_cluster records per failure class</done>
</task>

</tasks>

<verification>
- Security: secret, vulnerability, permission_drift triggers stored with correct metadata
- Verifier: import, compile, test (and install if present) each produce one record when that class fails
- All wrapped in try/except
</verification>

<success_criteria>
- MEM-09, MEM-10, MEM-11 satisfied
- No regression when memory disabled
</success_criteria>

<output>
After completion, create `.planning/phases/23-ingestion/23-03-SUMMARY.md`
</output>
