---
phase: 23-ingestion
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/booty/webhooks.py
  - src/booty/memory/__init__.py
autonomous: true

must_haves:
  truths:
    - "Sentry webhook: after create_sentry_issue_with_retry returns issue_number, add_record(incident) when memory enabled"
    - "Governor HOLD: after post_hold_status, add_record(governor_hold) when memory enabled"
    - "Deploy failure: after create_or_append_deploy_failure_issue, add_record(deploy_failure) when memory enabled"
  artifacts:
    - path: src/booty/webhooks.py
      provides: Memory ingestion for Observability, Governor HOLD, Deploy failure
      contains: add_record|build_incident_record|build_governor_hold_record|build_deploy_failure_record
  key_links:
    - from: sentry_webhook
      to: memory.add_record
      via: build_incident_record + add_record on success
      pattern: add_record
    - from: workflow_run HOLD branch
      to: memory.add_record
      via: build_governor_hold_record + add_record
      pattern: build_governor_hold_record
    - from: workflow_run deploy failure branch
      to: memory.add_record
      via: build_deploy_failure_record + add_record
      pattern: build_deploy_failure_record
---

<objective>
Wire Observability, Governor HOLD, and Deploy failure into Memory via webhooks.py. Load booty_config when needed; call add_record with try/except so ingestion never blocks agent flow.

Purpose: MEM-06, MEM-07, MEM-08 — incident, governor_hold, deploy_failure records stored on events.
Output: webhooks.py calls add_record at three integration points.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-ingestion/23-CONTEXT.md
@.planning/phases/23-ingestion/23-RESEARCH.md
@src/booty/webhooks.py
@src/booty/memory/adapters.py
@src/booty/memory/api.py
@src/booty/memory/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add booty_config loader for webhooks and wire Observability</name>
  <files>src/booty/webhooks.py</files>
  <action>
1. Add helper _load_booty_config_for_repo(repo_url: str, gh_token: str) -> BootyConfig | None:
   - Parse repo owner/name from repo_url (e.g. TARGET_REPO_URL or https://github.com/owner/repo)
   - Use Github(gh_token).get_repo(owner/repo).get_contents(".booty.yml", ref=default_branch)
   - load_booty_config_from_content(decoded)
   - Return config or None on any error (log warning, don't raise)

2. In sentry_webhook, after `if issue_number is not None` and before return:
   - booty_config = _load_booty_config_for_repo(settings.TARGET_REPO_URL, settings.GITHUB_TOKEN)
   - mem_config = get_memory_config(booty_config) if booty_config else None
   - if mem_config and mem_config.enabled: try: record = build_incident_record(event, issue_number, repo_from_url(settings.TARGET_REPO_URL)); add_record(record, mem_config); except Exception as e: logger.warning("memory_ingestion_failed", type="incident", error=str(e))
   - repo_from_url: parse TARGET_REPO_URL (https://github.com/o/r or git@... ) to "owner/repo"
   - Import: from booty.memory import add_record, get_memory_config; from booty.memory.adapters import build_incident_record
   - Apply apply_memory_env_overrides to mem_config if needed (get_memory_config returns validated; check if env overrides applied in get_memory_config — config.py shows get_memory_config does NOT apply overrides; caller should. Research says use get_memory_config. MemoryConfig from .booty.yml; env overrides in apply_memory_env_overrides. For consistency with Phase 22, apply overrides when loading for agents. Add: mem_config = apply_memory_env_overrides(mem_config) after get_memory_config when not None.)
  </action>
  <verify>python -c "
from booty.webhooks import _load_booty_config_for_repo
# Or: grep -n 'build_incident_record\|add_record' src/booty/webhooks.py | head -5
import ast
with open('src/booty/webhooks.py') as f:
    tree = ast.parse(f.read())
# Just check imports and that sentry_webhook references exist
"</verify>
  <done>Observability ingestion wired; incident records stored on successful issue creation</done>
</task>

<task type="auto">
  <name>Task 2: Wire Governor HOLD and Deploy failure</name>
  <files>src/booty/webhooks.py</files>
  <action>
1. Governor HOLD: In workflow_run block, when decision.outcome != "ALLOW" (the else branch after post_hold_status):
   - booty_config already loaded in this flow (from load_booty_config_from_content for governor_config). Reuse it — the same yaml_content loads full config. Parse: config = load_booty_config_from_content(yaml_content) — we have yaml_content from fc.decoded_content. So we have config (BootyConfig). mem_config = get_memory_config(config) if config else None; if mem_config: mem_config = apply_memory_env_overrides(mem_config). Then if mem_config and mem_config.enabled: try: record = build_governor_hold_record(decision, repo_full_name); add_record(record, mem_config); except: logger.warning(...)
   - Add imports for build_governor_hold_record, build_deploy_failure_record

2. Deploy failure: In is_deploy branch, when conclusion in ("failure", "cancelled"), after create_or_append_deploy_failure_issue returns:
   - We need booty_config here. Currently deploy branch doesn't load .booty.yml — it uses governor_config from earlier. But deploy outcome is handled BEFORE verification in the webhook flow — actually no, they're separate branches. is_deploy runs first for deploy workflow; is_verification runs for verify workflow. So when is_deploy, we don't have loaded config from earlier in the same request. We need to load .booty_config in the is_deploy branch when we want to ingest. Add: try: fc = gh_repo.get_contents(".booty.yml", ref=default_branch); config = load_booty_config_from_content(fc.decoded_content.decode()); mem_config = get_memory_config(config); mem_config = apply_memory_env_overrides(mem_config) if mem_config else None; except: mem_config = None
   - Then before create_or_append (or after): if mem_config and mem_config.enabled: try: record = build_deploy_failure_record(head_sha, run_url, conclusion, failure_type, repo_full_name); add_record(record, mem_config); except: logger.warning(...)
   - run_url = wr.get("html_url","") or wr.get("url","")
   - failure_type already computed
   - gh_repo is available in is_deploy (we have repo_full_name, but gh_repo — check: we have gh = Github(...), gh_repo = gh.get_repo(repo_full_name) in the workflow_run handler? No — in is_deploy we don't have gh_repo until... Look at code: create_or_append_deploy_failure_issue(gh_repo, head_sha, run_url, conclusion, failure_type). So gh_repo IS passed. Where does it come from? In is_deploy block, we have: gh = Github(settings.GITHUB_TOKEN) — not until we need it. Actually in the workflow_run handler we load config with gh = Github(...); gh_repo = gh.get_repo(repo_full_name). So gh_repo exists in workflow_run scope. is_deploy is inside that. So we have gh_repo. default_branch = gh_repo.default_branch or "main". Good.
  </action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -m pytest tests/ -v -k "memory or webhook" --ignore=tests/e2e 2>/dev/null | tail -15</verify>
  <done>Governor HOLD and Deploy failure ingestion wired</done>
</task>

</tasks>

<verification>
- Observability: issue creation success -> add_record(incident)
- Governor HOLD: post_hold_status -> add_record(governor_hold)
- Deploy failure/cancelled -> add_record(deploy_failure)
- All wrapped in try/except; failures logged, not raised
</verification>

<success_criteria>
- MEM-06, MEM-07, MEM-08 satisfied
- No regression in webhook behavior when memory disabled
</success_criteria>

<output>
After completion, create `.planning/phases/23-ingestion/23-02-SUMMARY.md`
</output>
