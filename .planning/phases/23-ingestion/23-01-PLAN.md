---
phase: 23-ingestion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/memory/adapters.py
  - src/booty/memory/__init__.py
  - tests/test_memory_adapters.py
autonomous: true

must_haves:
  truths:
    - "build_incident_record(event, issue_number, repo) returns dict with type=incident, repo, source=observability"
    - "build_governor_hold_record(decision, repo) returns dict with type=governor_hold, sha, reason"
    - "build_deploy_failure_record(sha, run_url, conclusion, failure_type, repo) returns dict with type=deploy_failure"
    - "build_security_block_record(job, trigger, title, summary, paths) returns dict with type=security_block, metadata.trigger"
    - "build_verifier_cluster_record(job, failure_type, paths, summary) returns dict with type=verifier_cluster, fingerprint"
    - "build_revert_record(repo, sha, reverted_sha, source) returns dict with type=revert"
  artifacts:
    - path: src/booty/memory/adapters.py
      provides: build_incident_record, build_governor_hold_record, build_deploy_failure_record, build_security_block_record, build_verifier_cluster_record, build_revert_record
      contains: build_incident_record|build_governor_hold_record
    - path: tests/test_memory_adapters.py
      provides: Adapter unit tests
  key_links:
    - from: adapters
      to: memory/schema
      via: Record dicts conform to MemoryRecord fields
      pattern: type.*repo.*source
---

<objective>
Create memory adapter functions that build record dicts for each ingestion source. No wiring yet — pure builders consumed by Plans 02–04.

Purpose: MEM-06 to MEM-12 — consistent record shapes per CONTEXT and RESEARCH.
Output: memory/adapters.py with 6 build_*_record functions; tests/test_memory_adapters.py.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-ingestion/23-CONTEXT.md
@.planning/phases/23-ingestion/23-RESEARCH.md
@src/booty/memory/schema.py
@src/booty/github/issues.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create adapters module and incident/governor/deploy adapters</name>
  <files>src/booty/memory/adapters.py</files>
  <action>
Create src/booty/memory/adapters.py with:

1. build_incident_record(event: dict, issue_number: int, repo: str) -> dict
   - type="incident", repo, source="observability", severity=event.get("level","error")
   - fingerprint=event.get("fingerprint") or event.get("issue_id","") or event.get("culprit","")[:200]
   - title=use build_sentry_issue_title from github/issues (import it)
   - summary=f"Sentry issue #{issue_number}"
   - sha="", pr_number=None (Sentry lacks these)
   - links=[{"url": f"https://github.com/{repo}/issues/{issue_number}", "type": "github_issue"}]
   - metadata={"issue_id": event.get("issue_id",""), "sentry_event": event.get("id")}
   - timestamp from event or datetime.now(timezone.utc).isoformat()

2. build_governor_hold_record(decision, repo: str) -> dict
   - decision has outcome, reason, risk_class, sha (from release_governor/decision.py Decision)
   - type="governor_hold", repo, sha=decision.sha, source="governor"
   - fingerprint=decision.reason, severity="high" if decision.risk_class=="HIGH" else "medium"
   - title=f"HOLD: {decision.reason} — {decision.sha[:7] if decision.sha else '?'}"
   - summary=f"Governor held deploy: {decision.reason}"
   - pr_number=None (Governor has SHA only)
   - metadata={"reason": decision.reason, "risk_class": decision.risk_class}

3. build_deploy_failure_record(sha: str, run_url: str, conclusion: str, failure_type: str, repo: str) -> dict
   - type="deploy_failure", repo, sha, source="governor"
   - fingerprint=sha, severity="high"
   - title=f"Deploy failure: {sha[:7] if sha else '?'}"
   - summary=f"Deploy {conclusion} — {failure_type}"
   - links=[{"url": run_url, "type": "workflow_run"}]
   - metadata={"conclusion": conclusion, "failure_type": failure_type}

Export all from memory/__init__.py if appropriate, or keep adapters internal (planner choice: add to __init__ exports).
  </action>
  <verify>python -c "
from booty.memory.adapters import build_incident_record, build_governor_hold_record, build_deploy_failure_record
from types import SimpleNamespace
# incident
r = build_incident_record({'level':'error','issue_id':'x'}, 42, 'owner/repo')
assert r['type']=='incident' and r['repo']=='owner/repo' and r['source']=='observability'
# governor_hold
d = SimpleNamespace(outcome='HOLD', reason='high_risk', risk_class='HIGH', sha='abc1234')
r2 = build_governor_hold_record(d, 'owner/repo')
assert r2['type']=='governor_hold' and r2['sha']=='abc1234' and 'high_risk' in r2['title']
# deploy_failure
r3 = build_deploy_failure_record('abc123', 'https://x', 'failure', 'deploy:health-check-failed', 'o/r')
assert r3['type']=='deploy_failure' and r3['metadata']['failure_type']=='deploy:health-check-failed'
print('OK')
"</verify>
  <done>build_incident_record, build_governor_hold_record, build_deploy_failure_record return valid record dicts</done>
</task>

<task type="auto">
  <name>Task 2: Add security, verifier, revert adapters</name>
  <files>src/booty/memory/adapters.py</files>
  <action>
Add to adapters.py:

4. build_security_block_record(job, trigger: str, title: str, summary: str, paths: list[str]) -> dict
   - job has owner, repo_name, head_sha, pr_number, base_sha (SecurityJob)
   - type="security_block", repo=f"{job.owner}/{job.repo_name}", sha=job.head_sha, pr_number=job.pr_number
   - source="security", fingerprint=f"security:{trigger}:{job.head_sha[:7]}"
   - severity="high" for secret/vulnerability, "medium" for permission_drift
   - metadata={"trigger": trigger} (trigger in "secret"|"vulnerability"|"permission_drift")
   - paths=paths (list of changed/touched paths)
   - title, summary as provided

5. build_verifier_cluster_record(job, failure_type: str, paths: list[str], summary: str) -> dict
   - job has owner, repo_name, head_sha, pr_number (VerifierJob)
   - type="verifier_cluster", repo=f"{job.owner}/{job.repo_name}", sha=job.head_sha, pr_number=job.pr_number
   - source="verifier"
   - fingerprint=f"{failure_type}:{hashlib.sha256('|'.join(sorted(paths)).encode()).hexdigest()[:16]}" if paths else f"{failure_type}:{job.head_sha[:7]}"
   - metadata={"failure_type": failure_type} (failure_type in "import"|"compile"|"test"|"install")
   - severity="high"

6. build_revert_record(repo: str, sha: str, reverted_sha: str, source: str = "push") -> dict
   - type="revert", repo, sha, source
   - fingerprint=sha, title=f"Revert {reverted_sha[:7]}"
   - summary=f"Reverted commit {reverted_sha[:7]}"
   - metadata={"reverted_sha": reverted_sha}
  </action>
  <verify>python -c "
from booty.memory.adapters import build_security_block_record, build_verifier_cluster_record, build_revert_record
from types import SimpleNamespace
# security
j = SimpleNamespace(owner='o', repo_name='r', head_sha='abc123', pr_number=1)
r = build_security_block_record(j, 'secret', 'Secret detected', 'summary', ['a.py'])
assert r['type']=='security_block' and r['metadata']['trigger']=='secret'
# verifier
r2 = build_verifier_cluster_record(j, 'compile', ['x.py'], 'compile failed')
assert r2['type']=='verifier_cluster' and 'compile' in r2['fingerprint']
# revert
r3 = build_revert_record('o/r', 'abc123', 'def456', 'push')
assert r3['type']=='revert' and r3['metadata']['reverted_sha']=='def456'
print('OK')
"</verify>
  <done>build_security_block_record, build_verifier_cluster_record, build_revert_record return valid record dicts</done>
</task>

<task type="auto">
  <name>Task 3: Add adapter unit tests</name>
  <files>tests/test_memory_adapters.py</files>
  <action>
Create tests/test_memory_adapters.py with pytest tests for each adapter:
- build_incident_record: assert type, repo, source, fingerprint present; handles missing fields
- build_governor_hold_record: assert sha, reason in title
- build_deploy_failure_record: assert metadata.conclusion, failure_type
- build_security_block_record: assert trigger in metadata, paths
- build_verifier_cluster_record: assert fingerprint contains failure_type
- build_revert_record: assert reverted_sha in metadata

Use pytest; follow existing test style from tests/test_memory_api.py.
  </action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -m pytest tests/test_memory_adapters.py -v</verify>
  <done>All adapter tests pass</done>
</task>

</tasks>

<verification>
- All 6 build_*_record functions return dicts with required MemoryRecord fields (type, repo, source, timestamp or added by add_record)
- Fingerprints follow CONTEXT rules (security: trigger; verifier: failure_type:paths_hash)
- Adapters are pure functions, no side effects
</verification>

<success_criteria>
- MEM-06 to MEM-12 record shapes defined and testable
- Adapters consumable by webhooks, security runner, verifier runner, CLI
</success_criteria>

<output>
After completion, create `.planning/phases/23-ingestion/23-01-SUMMARY.md`
</output>
