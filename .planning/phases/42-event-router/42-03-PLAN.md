---
phase: 42-event-router
plan: 03
type: execute
wave: 2
depends_on: [42-01, 42-02]
files_modified:
  - src/booty/router/router.py
  - src/booty/router/__init__.py
  - src/booty/webhooks.py
autonomous: true

must_haves:
  truths:
    - Webhook calls router as single dispatch; router normalizes, decides, enqueues
    - issues.labeled/opened → planner|builder per routing rules (ROUTE-02)
    - pull_request → reviewer|verifier|security per agent config (ROUTE-03)
    - workflow_run → governor.evaluate|observe_deploy (ROUTE-04)
    - All enqueue paths use should_run (ROUTE-05)
  artifacts:
    - path: src/booty/router/router.py
      provides: Canonical event router
      min_lines: 120
  key_links:
    - from: src/booty/webhooks.py
      to: src/booty/router
      via: route_github_event()
      pattern: route_github_event|router.route
---

<objective>
Extract canonical router; wire webhook to router; migrate all GitHub event paths. ROUTE-01 through ROUTE-05.

Purpose: Single event router; all events flow through normalize → should_run → enqueue.
Output: src/booty/router/router.py; webhooks.py delegates to router
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-event-router/42-CONTEXT.md
@.planning/phases/42-event-router/42-RESEARCH.md
@src/booty/webhooks.py
@src/booty/router/events.py
@src/booty/router/normalizer.py
@src/booty/router/should_run.py
</context>

<tasks>

<task type="auto">
  <name>Create router/router.py</name>
  <files>src/booty/router/router.py</files>
  <action>
Create src/booty/router/router.py with route_github_event:

Signature: route_github_event(event_type: str, payload: dict, delivery_id: str | None, app_state) -> dict
- app_state has: job_queue, verifier_queue, security_queue, reviewer_queue
- Returns: {"status": "accepted"|"ignored"|"already_processed", "reason": str?, "job_id": str?, ...}

Flow:
1. Normalize: internal = normalize(event_type, payload, delivery_id)
2. If internal is None: return {"status": "ignored", "reason": "unsupported_event"} (or event-specific)
3. Load booty_config for repo (reuse _load_booty_config_for_repo pattern from webhooks)
4. For each event family, build RoutingContext, call should_run per agent, enqueue when True

Issue events:
- If action in (opened, labeled) and trigger label: should_run(planner) → planner_enqueue; or plan exists → builder
- Architect/Builder wiring: get_plan_for_builder; architect_enabled → Architect vs Builder (same logic as webhooks today)
- Keep check_run, push, sentry as webhook-direct (not router) — they are side-channels; or route check_run if it maps to Memory

Pull request events:
- For verifier, security, reviewer: should_run(agent, repo, ctx) before enqueue
- Dedup: use existing queue APIs (pr_number, head_sha); router computes dedup key components

Workflow_run events:
- governor.evaluate (verification success) vs governor.observe_deploy (deploy outcome)
- Delegate to handle_workflow_run and deploy logic — router can normalize then call existing handlers

Incremental: router handles issues, pull_request, workflow_run. check_run, push, sentry remain in webhooks for now.
</action>
  <verify>python -c "from booty.router.router import route_github_event; print(callable(route_github_event))"</verify>
  <done>route_github_event exists; accepts event_type, payload, delivery_id, app_state</done>
</task>

<task type="auto">
  <name>Refactor webhooks to use router</name>
  <files>src/booty/webhooks.py</files>
  <action>
Refactor github_webhook in webhooks.py:

1. After verify_signature and parse payload, for event_type in (issues, pull_request, workflow_run):
   - Call route_github_event(event_type, payload, delivery_id, request.app.state)
   - Return JSONResponse or dict from router result

2. Keep check_run, push handling in webhooks (memory surfacing, revert detection) — these are not agent enqueue events per ROUTE-02/03/04

3. Ensure router receives all needed app_state: job_queue, verifier_queue, security_queue, reviewer_queue

4. Preserve existing response shapes: {"status": "accepted", "job_id": ...}, {"status": "ignored", "reason": ...}, etc.

5. Remove duplicated routing logic from webhooks (move to router); webhooks becomes thin dispatch + check_run + push + sentry
</action>
  <verify>grep -n "route_github_event\|router.route" src/booty/webhooks.py</verify>
  <done>Webhook delegates issues, pull_request, workflow_run to router</done>
</task>

<task type="auto">
  <name>Minimal skip observability</name>
  <files>src/booty/router/router.py</files>
  <action>
When router returns ignored: ensure structured log with agent (if applicable), repo, event_type, decision=skip, reason.
Per 42-CONTEXT: minimal skip observability acceptable; full OPS-01 in Phase 47.
Log format: logger.info("event_skip", agent=..., repo=..., event_type=..., reason=...)
</action>
  <verify>grep -n "event_skip\|decision=skip" src/booty/router/router.py</verify>
  <done>Skip path emits structured log</done>
</task>

<task type="auto">
  <name>Update router package exports</name>
  <files>src/booty/router/__init__.py</files>
  <action>
Add route_github_event to router/__init__.py exports
</action>
  <verify>python -c "from booty.router import route_github_event; print('ok')"</verify>
  <done>router exports route_github_event</done>
</task>

</tasks>

<verification>
- ROUTE-01: Extracted router; operator can observe (logs)
- ROUTE-02: issues.labeled/opened → planner|builder
- ROUTE-03: pull_request → reviewer|verifier|security per config
- ROUTE-04: workflow_run → governor
- ROUTE-05: All enqueue paths use should_run
</verification>

<success_criteria>
- Router module complete; webhook uses it for issues, pull_request, workflow_run
- Existing tests pass (or update if webhook interface changed)
</success_criteria>

<output>
After completion, create .planning/phases/42-event-router/42-03-SUMMARY.md
</output>
