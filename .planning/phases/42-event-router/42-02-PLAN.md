---
phase: 42-event-router
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/router/should_run.py
  - src/booty/router/__init__.py
autonomous: true

must_haves:
  truths:
    - should_run(agent, repo, context) is single decision point for all enqueue paths
    - Precedence: env overrides file; file over default
    - enabled(agent) and should_run(agent, ctx) are two layers
  artifacts:
    - path: src/booty/router/should_run.py
      provides: should_run decision with config+env precedence
      min_lines: 80
  key_links:
    - from: src/booty/router
      to: booty.config
      via: get_settings, planner_enabled, verifier_enabled, security_enabled
      pattern: should_run
---

<objective>
Implement single should_run(agent, repo, context) decision point. ROUTE-05: config+env precedence governs all enqueue decisions.

Purpose: Centralize enablement and routing; prevent scattered checks across webhook.
Output: src/booty/router/should_run.py
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-event-router/42-CONTEXT.md
@.planning/phases/42-event-router/42-RESEARCH.md
@src/booty/config.py
@src/booty/webhooks.py
</context>

<tasks>

<task type="auto">
  <name>Create should_run module</name>
  <files>src/booty/router/should_run.py</files>
  <action>
Create src/booty/router/should_run.py:

1. Agent enum or literal: "planner", "builder", "architect", "verifier", "security", "reviewer", "governor"

2. enabled(agent: str, settings, booty_config=None) -> bool
   - planner: planner_enabled(settings)
   - verifier, security, reviewer: verifier_enabled(settings) or security_enabled(settings) per agent (reviewer same App as verifier)
   - builder: always True when job_queue exists (or check planner_enabled as proxy for Builder pipeline)
   - architect: from booty_config.architect via get_architect_config; apply_architect_env_overrides
   - governor: from booty_config.release_governor; apply_release_governor_env_overrides
   - Global kill switch: if BOOTY_DISABLED=1|true|yes in env, return False for all
   - Per-agent env: PLANNER_ENABLED, etc. (Settings already has PLANNER_ENABLED)

3. RoutingContext: TypedDict with repo_full_name, event_type, action, is_agent_pr (for PR), issue_number (for issues), etc.
   - Minimal fields needed for gating (e.g. Reviewer: is_agent_pr; Planner: has trigger label)

4. should_run(agent: str, repo_full_name: str, context: RoutingContext, settings, booty_config=None) -> bool
   - First: if not enabled(agent, ...): return False
   - Then: routing/gating:
     - reviewer: requires is_agent_pr in context
     - planner: requires trigger label or equivalent (from context)
     - builder: requires plan existence (handled in flow controller, not router — router just checks enabled)
   - Default: return enabled(agent, ...) when no extra gating

5. Document precedence in docstring: Env > File > Default
</action>
  <verify>python -c "from booty.router.should_run import should_run, enabled; from booty.config import get_settings; s=get_settings(); print(enabled('planner', s))"</verify>
  <done>should_run and enabled callable; global kill switch supported</done>
</task>

<task type="auto">
  <name>Wire Reviewer per-repo config</name>
  <files>src/booty/router/should_run.py</files>
  <action>
For reviewer: enabled(agent) uses verifier_enabled (same App). Per-repo ReviewerConfig.enabled from .booty.yml is loaded in runner — router uses global "Reviewer on when App present". should_run adds gating: is_agent_pr.

No changes needed if runner already loads ReviewerConfig — router stays simple.
</action>
  <verify>grep -n "is_agent_pr\|reviewer" src/booty/router/should_run.py</verify>
  <done>Reviewer gating via is_agent_pr documented or implemented</done>
</task>

<task type="auto">
  <name>Export from router package</name>
  <files>src/booty/router/__init__.py</files>
  <action>
Add to router/__init__.py: enabled, should_run, RoutingContext from .should_run
</action>
  <verify>python -c "from booty.router import should_run, enabled; print('ok')"</verify>
  <done>router exports should_run, enabled</done>
</task>

</tasks>

<verification>
- ROUTE-05: Single should_run with config+env precedence
- Global kill switch (BOOTY_DISABLED) supported
- enabled vs should_run layers
</verification>

<success_criteria>
- should_run.py with enabled(), should_run(), RoutingContext
- All enqueue paths will use should_run (Plan 03 wires it)
</success_criteria>

<output>
After completion, create .planning/phases/42-event-router/42-02-SUMMARY.md
</output>
