---
phase: 22-memory-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/memory/__init__.py
  - src/booty/memory/config.py
  - src/booty/test_runner/config.py
  - tests/test_memory_config.py
autonomous: true

must_haves:
  truths:
    - "MemoryConfig schema accepts enabled, retention_days, max_matches, comment_on_pr, comment_on_incident_issue"
    - "Env vars MEMORY_ENABLED, MEMORY_RETENTION_DAYS, MEMORY_MAX_MATCHES override .booty.yml values"
    - "BootyConfigV1.memory holds raw dict; invalid memory block fails Memory only (lazy validation)"
  artifacts:
    - path: src/booty/memory/config.py
      provides: MemoryConfig, apply_memory_env_overrides
      contains: MemoryConfig
    - path: src/booty/test_runner/config.py
      provides: BootyConfigV1.memory
      contains: memory
    - path: tests/test_memory_config.py
      provides: MemoryConfig validation tests
  key_links:
    - from: BootyConfigV1
      to: memory
      via: memory optional field (dict | None)
      pattern: memory.*dict
---

<objective>
Add MemoryConfig schema to .booty.yml with env override support.

Purpose: MEM-24, MEM-25, MEM-26 — memory block (enabled, retention_days, max_matches, comment_on_pr, comment_on_incident_issue); unknown keys fail Memory only via lazy validation; env overrides MEMORY_ENABLED, MEMORY_RETENTION_DAYS, MEMORY_MAX_MATCHES.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-memory-foundation/22-CONTEXT.md
@.planning/phases/22-memory-foundation/22-RESEARCH.md
@src/booty/test_runner/config.py
@.planning/phases/18-security-foundation-check/18-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MemoryConfig and extend BootyConfigV1</name>
  <files>src/booty/test_runner/config.py</files>
  <action>
1. Create src/booty/memory/ package with __init__.py and config.py.

2. In memory/config.py create MemoryConfig Pydantic model with model_config = ConfigDict(extra="forbid"). Fields: enabled: bool = True, retention_days: int = 90 (ge=1, le=365), max_matches: int = 3 (ge=1, le=20), comment_on_pr: bool = True, comment_on_incident_issue: bool = True.

3. In test_runner/config.py add memory: dict | None = None to BootyConfigV1. Use field_validator(mode="before") on memory: when value is dict, return as-is; when None or absent, return None. Do NOT validate — Memory module validates lazily (fail Memory only per MEM-25).

4. Ensure _parse_booty_config and load_booty_config_from_content handle memory. Backward compat: repos without memory key load with memory=None.
  </action>
  <verify>python -c "
from booty.test_runner.config import load_booty_config_from_content
c = load_booty_config_from_content('schema_version: 1\ntest_command: pytest\nmemory:\n  enabled: true\n  retention_days: 90')
assert c.memory is not None
assert c.memory.get('enabled') is True
assert c.memory.get('retention_days') == 90
c2 = load_booty_config_from_content('schema_version: 1\ntest_command: pytest')
assert c2.memory is None
"</verify>
  <done>BootyConfigV1 loads .booty.yml with optional memory block as raw dict; MemoryConfig will validate on use</done>
</task>

<task type="auto">
  <name>Task 2: Add apply_memory_env_overrides</name>
  <files>src/booty/memory/config.py</files>
  <action>
Add apply_memory_env_overrides(config: MemoryConfig) -> MemoryConfig in memory/config.py. Apply env vars (MEMORY_* per MEM-26):
- MEMORY_ENABLED: "1"/"true"/"yes" -> enabled=True; "0"/"false"/"no" -> enabled=False
- MEMORY_RETENTION_DAYS: int, ge=1 le=365
- MEMORY_MAX_MATCHES: int, ge=1 le=20

Return config.model_copy(update=overrides) when overrides present, else return config unchanged. Mirror apply_security_env_overrides and apply_release_governor_env_overrides pattern.
  </action>
  <verify>MEMORY_ENABLED=false python -c "
from booty.memory.config import MemoryConfig, apply_memory_env_overrides
import os
os.environ['MEMORY_ENABLED'] = 'false'
c = MemoryConfig(enabled=True)
c2 = apply_memory_env_overrides(c)
assert c2.enabled is False
"</verify>
  <done>Env vars MEMORY_ENABLED, MEMORY_RETENTION_DAYS, MEMORY_MAX_MATCHES override MemoryConfig values</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for MemoryConfig</name>
  <files>tests/test_memory_config.py</files>
  <action>
Create tests/test_memory_config.py. Test cases:
1. MemoryConfig accepts valid config (enabled, retention_days, max_matches, comment_on_pr, comment_on_incident_issue)
2. MemoryConfig rejects unknown keys (extra="forbid")
3. BootyConfigV1 with valid memory block loads with memory dict
4. BootyConfigV1 without memory key loads with memory=None
5. apply_memory_env_overrides applies MEMORY_ENABLED, MEMORY_RETENTION_DAYS, MEMORY_MAX_MATCHES

MemoryConfig in booty.memory.config; BootyConfigV1.memory is raw dict in test_runner.config.
  </action>
  <verify>pytest tests/test_memory_config.py -v</verify>
  <done>MemoryConfig and env override behavior covered by tests</done>
</task>
</tasks>

<verification>
- BootyConfigV1 extends with memory: dict | None
- MemoryConfig validates strictly; unknown keys raise
- apply_memory_env_overrides works for MEMORY_* vars
</verification>

<success_criteria>
- MEM-24, MEM-25, MEM-26 satisfied
- Config loads without breaking existing agents
- Memory uses lazy validation so invalid block fails Memory only
</success_criteria>

<output>
After completion, create .planning/phases/22-memory-foundation/22-01-SUMMARY.md
</output>
