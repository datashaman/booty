---
phase: 22-memory-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/booty/memory/schema.py
  - src/booty/memory/store.py
  - tests/test_memory_store.py
autonomous: true

must_haves:
  truths:
    - "Records persist to memory.jsonl in state dir; writes are atomic with fsync"
    - "Reads tolerate partial last line (skip on JSONDecodeError)"
    - "MemoryRecord schema has id, type, timestamp, repo, sha, pr_number, source, severity, fingerprint, title, summary, paths, links, metadata"
  artifacts:
    - path: src/booty/memory/store.py
      provides: append_record, read_records, get_memory_state_dir
      contains: append_record
    - path: src/booty/memory/schema.py
      provides: MemoryRecord
      contains: MemoryRecord
  key_links:
    - from: store.append_record
      to: memory.jsonl
      via: append with fsync
      pattern: os.fsync
---

<objective>
Implement append-only memory.jsonl storage with schema and durable writes.

Purpose: MEM-01, MEM-02, MEM-03, MEM-05 — storage in configured state dir; atomic append with fsync; stable schema; records survive restarts.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-memory-foundation/22-CONTEXT.md
@.planning/phases/22-memory-foundation/22-RESEARCH.md
@src/booty/release_governor/store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MemoryRecord schema</name>
  <files>src/booty/memory/schema.py</files>
  <action>
Create src/booty/memory/schema.py. Define MemoryRecord as TypedDict with optional fields per MEM-03:
- id, type, timestamp, repo, sha, pr_number, source, severity, fingerprint, title, summary, paths, links, metadata

Use total=False so all fields optional for construction; required fields enforced at add_record time (type, timestamp at minimum). Plan 01 creates memory package; ensure schema.py integrates.
  </action>
  <verify>python -c "
from booty.memory.schema import MemoryRecord
r: MemoryRecord = {'type': 'incident', 'repo': 'owner/repo', 'title': 'Test'}
assert 'type' in r
"</verify>
  <done>MemoryRecord schema defines common fields; memory package exists</done>
</task>

<task type="auto">
  <name>Task 2: Implement store with append and read</name>
  <files>src/booty/memory/store.py</files>
  <action>
Create store.py with:

1. get_memory_state_dir() -> Path: Precedence MEMORY_STATE_DIR env > $HOME/.booty/state > ./.booty/state. mkdir(parents=True, exist_ok=True). Mirror release_governor/store.py get_state_dir pattern.

2. append_record(path: Path, record: dict) -> None: Open path in append mode; fcntl.flock(LOCK_EX); write json.dumps(record, default=str) + newline; f.flush(); os.fsync(f.fileno()); LOCK_UN. Create parent dir if missing.

3. read_records(path: Path) -> list[dict]: Open, iterate lines; for each line try json.loads(line); on JSONDecodeError skip (partial last line). Return list of records.

4. _memory_jsonl_path(state_dir: Path) -> Path: return state_dir / "memory.jsonl"

No compaction in this plan — Phase 22 can ship with append-only; MEM-04 compaction deferred or minimal.
  </action>
  <verify>python -c "
from pathlib import Path
import tempfile
from booty.memory.store import get_memory_state_dir, append_record, read_records
with tempfile.TemporaryDirectory() as d:
    import os
    os.environ['MEMORY_STATE_DIR'] = d
    try:
        state_dir = get_memory_state_dir()
        path = state_dir / 'memory.jsonl'
        append_record(path, {'type':'test','id':'x'})
        recs = read_records(path)
        assert len(recs) == 1
        assert recs[0]['type'] == 'test'
    finally:
        os.environ.pop('MEMORY_STATE_DIR', None)
"</verify>
  <done>append_record writes durably; read_records tolerates partial last line</done>
</task>

<task type="auto">
  <name>Task 3: Add store tests</name>
  <files>tests/test_memory_store.py</files>
  <action>
Create tests/test_memory_store.py. Test cases:
1. get_memory_state_dir uses MEMORY_STATE_DIR when set
2. append_record persists record; read_records returns it
3. read_records skips partial last line (truncated JSON)
4. append_record creates dir if missing
5. Multiple appends yield multiple records in order

Use tmp_path or monkeypatch MEMORY_STATE_DIR for isolation.
  </action>
  <verify>pytest tests/test_memory_store.py -v</verify>
  <done>Store behavior covered by tests</done>
</task>
</tasks>

<verification>
- memory.jsonl created in state dir
- Each write is flushed and fsynced
- Partial last line skipped on read
- Schema matches MEM-03
</verification>

<success_criteria>
- MEM-01, MEM-02, MEM-03, MEM-05 satisfied
- No new dependencies
- Survives process restart (records on disk)
</success_criteria>

<output>
After completion, create .planning/phases/22-memory-foundation/22-02-SUMMARY.md
</output>
