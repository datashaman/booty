---
phase: 22-memory-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01", "02"]
files_modified:
  - src/booty/memory/__init__.py
  - src/booty/memory/config.py
  - src/booty/memory/api.py
  - tests/test_memory_api.py
autonomous: true

must_haves:
  truths:
    - "memory.add_record(record) API returns { added: true, id: ... } or { added: false, reason: duplicate, existing_id: ... }"
    - "Dedup by (type, repo, sha, fingerprint, pr_number) within 24h; exclude null/empty from key"
    - "When memory disabled, add_record returns success without persisting"
  artifacts:
    - path: src/booty/memory/api.py
      provides: add_record
      contains: add_record
    - path: src/booty/memory/__init__.py
      provides: add_record export
  key_links:
    - from: add_record
      to: store.append_record
      via: calls after dedup check
      pattern: append_record
    - from: add_record
      to: MemoryConfig
      via: checks enabled, uses retention_days
      pattern: config.enabled
---

<objective>
Implement memory.add_record API with dedup semantics.

Purpose: MEM-13, MEM-14 — add_record(record) available for agents; dedup within 24h by (type, repo, sha, fingerprint, pr_number); exclude null/empty from key; keep-first semantics.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-memory-foundation/22-CONTEXT.md
@.planning/phases/22-memory-foundation/22-RESEARCH.md
@src/booty/memory/store.py
@src/booty/memory/schema.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_memory_config for lazy validation</name>
  <files>src/booty/memory/config.py</files>
  <action>
Add get_memory_config(booty_config) -> MemoryConfig | None to memory/config.py (plan 01 creates MemoryConfig there). Logic:
- If booty_config.memory is None, return None.
- Else try MemoryConfig.model_validate(booty_config.memory); on ValidationError raise MemoryConfigError(f"Memory config invalid: {e}") — includes unknown key in message. Implements MEM-25 (fail Memory only).

Define MemoryConfigError as a simple Exception subclass in config.py.
  </action>
  <verify>python -c "
from booty.memory.config import MemoryConfig, get_memory_config
from types import SimpleNamespace
# Valid
c = SimpleNamespace(memory={'enabled': True, 'retention_days': 90})
mc = get_memory_config(c)
assert mc.enabled is True
# Invalid - unknown key
c2 = SimpleNamespace(memory={'enabled': True, 'typo_key': 1})
try:
    get_memory_config(c2)
except Exception as e:
    assert 'typo_key' in str(e) or 'invalid' in str(e).lower()
"</verify>
  <done>get_memory_config validates BootyConfig.memory; unknown keys raise MemoryConfigError</done>
</task>

<task type="auto">
  <name>Task 2: Implement add_record with dedup</name>
  <files>src/booty/memory/api.py</files>
  <action>
Create add_record(record: dict, config: MemoryConfig, state_dir: Path | None = None) -> dict:

1. If not config.enabled: return {"added": True, "id": None} (no-op, idempotent per CONTEXT).

2. state_dir = state_dir or get_memory_state_dir() from store.

3. Build dedup key from record: include only (type, repo, sha, fingerprint, pr_number) where value is not None and not empty string. Normalize to comparable tuple for lookup.

4. Scan read_records(state_dir / "memory.jsonl") for records with same dedup key where (now - record.timestamp) < 24 hours. Parse timestamp; use datetime.fromisoformat. If found: return {"added": False, "reason": "duplicate", "existing_id": existing["id"]}.

5. Generate record_id = str(uuid.uuid4()). Set record["id"] = record_id. Set record["timestamp"] = datetime.now(timezone.utc).isoformat() if not already set.

6. append_record(path, record). Return {"added": True, "id": record_id}.

Dedup logic: _build_dedup_key(record) -> tuple of (type, repo, sha, fingerprint, pr_number) excluding None/empty. _find_duplicate(state_dir, key, within_hours=24) -> dict | None.
  </action>
  <verify>python -c "
import tempfile
import os
from pathlib import Path
from booty.memory.api import add_record
from booty.memory.config import MemoryConfig
os.environ['MEMORY_STATE_DIR'] = tempfile.mkdtemp()
config = MemoryConfig(enabled=True)
r1 = add_record({'type':'incident','repo':'o/r','sha':'abc'}, config)
assert r1['added'] is True
assert 'id' in r1
r2 = add_record({'type':'incident','repo':'o/r','sha':'abc'}, config)
assert r2['added'] is False
assert r2['reason'] == 'duplicate'
assert r2['existing_id'] == r1['id']
"</verify>
  <done>add_record persists when enabled; dedup returns duplicate for same key within 24h</done>
</task>

<task type="auto">
  <name>Task 3: Export add_record and add tests</name>
  <files>src/booty/memory/__init__.py</files>
  <files>tests/test_memory_api.py</files>
  <action>
1. Update booty/memory/__init__.py to export add_record, get_memory_config, MemoryConfig (from api and config).

2. Create tests/test_memory_api.py:
   - add_record when disabled returns success, no persist
   - add_record when enabled persists and returns id
   - add_record dedup: same key within 24h returns duplicate
   - add_record dedup: same key after 24h allows second (or mock time)
   - add_record excludes null/empty from dedup key (differentiate records with/without fingerprint)
   - get_memory_config raises on unknown key
  </action>
  <verify>pytest tests/test_memory_api.py -v</verify>
  <done>add_record API and dedup covered by tests; memory module exports correctly</done>
</task>
</tasks>

<verification>
- add_record returns correct shape for add vs duplicate
- Dedup key excludes None/empty
- 24h window enforced
- Disabled = no-op
</verification>

<success_criteria>
- MEM-13, MEM-14 satisfied
- API usable by ingestion phases (23+)
- get_memory_config fails Memory only on unknown keys
</success_criteria>

<output>
After completion, create .planning/phases/22-memory-foundation/22-03-SUMMARY.md
</output>
