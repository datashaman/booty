---
phase: 09-diff-limits-schema-v1
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/test_runner/config.py
autonomous: true

must_haves:
  truths:
    - "BootyConfig supports schema_version 0 (existing) and 1 (strict with new fields)"
    - "Repos without schema_version use v0 (existing BootyConfig)"
    - "schema_version 1 rejects unknown keys (extra='forbid')"
    - "load_booty_config_from_content(yaml_str) parses and validates without workspace"
  artifacts:
    - path: src/booty/test_runner/config.py
      provides: BootyConfig with schema_version, BootyConfigV1, load_booty_config_from_content
      contains: "schema_version|load_booty_config_from_content|BootyConfigV1"
  key_links:
    - from: config.py
      to: executor
      via: config.timeout (from timeout_seconds in v1)
      pattern: timeout|timeout_seconds
---

<objective>
Extend BootyConfig with schema_version and schema v1 fields; add strict validation for v1; add load_booty_config_from_content for Verifier's API-fetched YAML.

Purpose: VERIFY-09, VERIFY-10 — .booty.yml validated against schema; schema v1 supports new fields.
Output: schema_version handling, BootyConfigV1 (or extended BootyConfig), load_booty_config_from_content.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-diff-limits-schema-v1/09-RESEARCH.md
@.planning/phases/09-diff-limits-schema-v1/09-CONTEXT.md
@src/booty/test_runner/config.py
@src/booty/test_runner/executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend BootyConfig with schema_version and v1 fields</name>
  <files>src/booty/test_runner/config.py</files>
  <action>
Extend BootyConfig for schema v1:

1. Keep existing BootyConfig as v0 (no schema_version or schema_version=0):
   - test_command, timeout, max_retries, protected_paths (unchanged)
   - Add optional schema_version: int = 0
   - When schema_version is 0 or absent: allow extra keys (current behavior)

2. Create BootyConfigV1 or use model discriminator:
   - Option A: Single BootyConfig with conditional extra='forbid' when schema_version==1
   - Option B: BootyConfigV1 subclass with extra='forbid' and all v1 fields
   - Use Option B for clarity: BootyConfigV1 extends/duplicates fields with strict validation

3. Schema v1 fields (from REQUIREMENTS + CONTEXT):
   - schema_version: Literal[1] = 1
   - test_command: str (required)
   - setup_command: str | None = None
   - timeout_seconds: int = 300 (ge=10, le=3600) — map to .timeout for executor
   - max_retries: int = 3
   - allowed_paths: list[str] = []
   - forbidden_paths: list[str] = []
   - allowed_commands: list[str] = []
   - network_policy: Literal["deny_all", "registry_only", "allow_list"] | None = None
   - labels: dict[str, str] = {}  # agent_pr_label, task_label, blocked_label
   - max_files_changed: int | None = None
   - max_diff_loc: int | None = None
   - max_loc_per_file: int | None = None
   - max_loc_per_file_pathspec: list[str] | None = None  # default !tests/**
   - protected_paths: list[str] (keep, with defaults)

4. BootyConfigV1.model_config = ConfigDict(extra='forbid')

5. Executor compatibility: BootyConfigV1 must expose .timeout (from timeout_seconds) so execute_tests(config.test_command, config.timeout, ...) works.

6. Update load_booty_config(workspace_path): after yaml.safe_load(data), check data.get("schema_version") == 1; if so use BootyConfigV1.model_validate(data), else BootyConfig.model_validate(data). Same dispatch as load_booty_config_from_content.
</action>
  <verify>
cd /Users/marlinf/Projects/datashaman/booty && python -c "
from booty.test_runner.config import BootyConfig, load_booty_config
# v0 still works
c0 = BootyConfig(test_command='pytest')
assert c0.timeout == 300
# load_booty_config unchanged for path
from pathlib import Path
import tempfile
with tempfile.TemporaryDirectory() as d:
    p = Path(d) / '.booty.yml'
    p.write_text('test_command: pytest')
    c = load_booty_config(Path(d))
    assert c.test_command == 'pytest'
print('OK: BootyConfig v0 works')
"
  </verify>
  <done>BootyConfig supports schema_version; BootyConfigV1 or strict mode exists.</done>
</task>

<task type="auto">
  <name>Task 2: Add load_booty_config_from_content</name>
  <files>src/booty/test_runner/config.py</files>
  <action>
Add load_booty_config_from_content(yaml_content: str, workspace_path: Path | None = None) -> BootyConfig | BootyConfigV1:

1. Parse YAML with yaml.safe_load
2. If data is None: raise ValueError('.booty.yml is empty')
3. Check schema_version in data:
   - If schema_version == 1: validate with BootyConfigV1, return instance
   - Else (0, missing, or other): validate with BootyConfig (current), return instance
4. BootyConfigV1 must have .timeout property returning timeout_seconds value for executor compatibility
5. If missing .booty.yml (caller passes empty or None): have caller use load_booty_config(path) for defaults, or add load_booty_config_from_content("") -> BootyConfig(test_command="echo 'No tests configured'") for empty string?

Actually: load_booty_config_from_content is for when we HAVE content (from API). If content is empty/missing, caller handles. So:
- load_booty_config_from_content(content: str) -> BootyConfig
- Raises if content is empty/None after strip
- Returns BootyConfig or BootyConfigV1 based on schema_version in parsed data
</action>
  <verify>
cd /Users/marlinf/Projects/datashaman/booty && python -c "
from booty.test_runner.config import load_booty_config_from_content
# v0 content
c0 = load_booty_config_from_content('test_command: pytest')
assert c0.test_command == 'pytest'
# v1 content
c1 = load_booty_config_from_content('schema_version: 1\\ntest_command: pytest\\ntimeout_seconds: 60')
assert c1.timeout == 60
# v1 strict: unknown key fails
try:
    load_booty_config_from_content('schema_version: 1\\ntest_command: pytest\\nunknown_field: x')
    assert False, 'Should raise'
except Exception as e:
    assert 'extra' in str(e).lower() or 'unknown' in str(e).lower() or 'forbid' in str(e).lower()
print('OK: load_booty_config_from_content works')
"
  </verify>
  <done>load_booty_config_from_content parses YAML and returns validated config.</done>
</task>

</tasks>

<verification>
- BootyConfig v0 unchanged for repos without schema_version
- BootyConfigV1 strict (unknown keys fail)
- load_booty_config_from_content exists and handles v0/v1
- timeout/timeout_seconds map correctly for executor
</verification>

<success_criteria>
- [ ] schema_version 0 and 1 supported
- [ ] v1 rejects unknown keys
- [ ] load_booty_config_from_content works for Verifier
- [ ] Backward compat: existing .booty.yml files work
</success_criteria>

<output>
After completion, create `.planning/phases/09-diff-limits-schema-v1/09-01-SUMMARY.md`
</output>
