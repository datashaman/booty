---
phase: 24-lookup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/memory/lookup.py
  - src/booty/memory/__init__.py
  - tests/test_memory_lookup.py
autonomous: true

must_haves:
  truths:
    - "query(paths, repo, sha, fingerprint?, config, state_dir?) returns matches from last 90 days"
    - "Matches by path intersection (prefix/containment) OR fingerprint"
    - "Results sorted by severity desc, recency desc, path overlap desc, id asc"
    - "Result subset: type, timestamp, summary, links, id; limit from config.max_matches (override via param)"
    - "Deterministic; <1s for 10k records"
  artifacts:
    - path: src/booty/memory/lookup.py
      provides: query, normalize_path, path_match_score
      contains: def query
    - path: tests/test_memory_lookup.py
      provides: Lookup unit tests
  key_links:
    - from: lookup.query
      to: store.read_records
      via: Load records from memory.jsonl
      pattern: read_records
---

<objective>
Implement deterministic lookup query engine: accept candidate (paths, repo, sha, optional fingerprint), return related memory records from last 90 days. Path intersection OR fingerprint; sort by severity, recency, path overlap; limit by config.

Purpose: MEM-15 to MEM-18 â€” lookup for Surfacing (Phase 25) and CLI (Phase 26).
Output: lookup.py with query() API; exported from memory.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-lookup/24-CONTEXT.md
@.planning/phases/24-lookup/24-RESEARCH.md
@src/booty/memory/store.py
@src/booty/memory/config.py
@src/booty/memory/schema.py
@src/booty/memory/adapters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Path normalization and matching</name>
  <files>src/booty/memory/lookup.py</files>
  <action>
Create src/booty/memory/lookup.py with:

1. normalize_path(p: str) -> str
   - Strip, replace backslash with forward slash, lstrip "./"
   - Use pathlib.PurePosixPath (GitHub/repo paths are POSIX); return str
   - Empty/invalid input -> ""

2. path_match_score(candidate_paths: list[str], record_paths: list[str]) -> int
   - For each candidate path: check prefix/containment with each record path per CONTEXT
   - Exact match = 2, prefix match (either direction) = 1; sum across pairs
   - Return total overlap score for the record

3. fingerprint_matches(candidate_fp: str | None, record_fp: str | None) -> bool
   - Both must be non-empty strings; compare after strip
   - Return True if record_fp == candidate_fp

4. derive_paths_hash(paths: list[str]) -> str
   - For verifier_cluster: hashlib.sha256("|".join(sorted(paths)).encode()).hexdigest()[:16]
   - Matches adapters.build_verifier_cluster_record fingerprint logic
   - Used when caller has paths but no fingerprint, to match verifier_cluster records by type prefix (import:|compile:|test:|install:)
  </action>
  <verify>python -c "
from booty.memory.lookup import normalize_path, path_match_score, fingerprint_matches, derive_paths_hash
assert normalize_path('  src/foo/bar  ') == 'src/foo/bar'
assert normalize_path('./a/b') == 'a/b'
assert path_match_score(['src/foo'], ['src/foo']) >= 2
assert path_match_score(['src/foo'], ['src/foo/new.py']) >= 1
assert fingerprint_matches('x', 'x') and not fingerprint_matches('x', 'y')
assert len(derive_paths_hash(['a.py','b.py'])) == 16
print('OK')
"</verify>
  <done>Path normalization and matching helpers work per CONTEXT rules</done>
</task>

<task type="auto">
  <name>Task 2: Filter, sort, limit, result subset</name>
  <files>src/booty/memory/lookup.py</files>
  <action>
Add to lookup.py:

1. within_retention(record: dict, retention_days: int) -> bool
   - Parse record["timestamp"] with datetime.fromisoformat(ts.replace("Z","+00:00"))
   - cutoff = now - timedelta(days=retention_days); record passes if dt >= cutoff
   - Missing/invalid timestamp -> False

2. repo_matches(record: dict, repo: str | None) -> bool
   - If repo is None/empty, return True
   - Compare record["repo"] (normalized) to repo (normalized)

3. SEVERITY_ORDER = {"critical":0, "high":1, "medium":2, "low":3, "unknown":4}
   - Missing severity -> treat as "unknown"

4. sort_key(record: dict) -> tuple for sorted()
   - (severity_rank, -timestamp_epoch, -path_overlap, id)
   - severity_rank from SEVERITY_ORDER; timestamp as epoch for reverse recency

5. result_subset(record: dict) -> dict
   - Return only: type, timestamp (or date string), summary, links, id
   - Per CONTEXT: "type, date, summary, link, id"
  </action>
  <verify>python -c "
from booty.memory.lookup import within_retention, repo_matches, sort_key, result_subset
from datetime import datetime, timedelta, timezone
now = datetime.now(timezone.utc)
r = {'timestamp': (now - timedelta(days=1)).isoformat(), 'repo':'o/r', 'severity':'high', 'path_overlap':2, 'id':'x'}
assert within_retention(r, 90)
assert repo_matches(r, 'o/r')
r2 = {'timestamp': (now - timedelta(days=100)).isoformat()}
assert not within_retention(r2, 90)
r3 = {'type':'incident','timestamp':'2024-01-01','summary':'x','links':[],'id':'y'}
assert set(result_subset(r3)) <= {'type','timestamp','summary','links','id'}
print('OK')
"</verify>
  <done>Filter, sort, and result subset logic implemented</done>
</task>

<task type="auto">
  <name>Task 3: query() API and tests</name>
  <files>src/booty/memory/lookup.py, src/booty/memory/__init__.py, tests/test_memory_lookup.py</files>
  <action>
Implement query() in lookup.py:

def query(
    paths: list[str],
    repo: str,
    sha: str | None = None,
    fingerprint: str | None = None,
    config: MemoryConfig | None = None,
    state_dir: Path | None = None,
    max_matches: int | None = None,
) -> list[dict]:
  """
  Return related memory records from last 90 days.
  Match by path intersection OR fingerprint (additive).
  Sorted per MEM-17; limited by max_matches or config.max_matches.
  Returns result subset (type, timestamp, summary, links, id).
  """
  - If not paths and not fingerprint: return []
  - state_dir = state_dir or get_memory_state_dir()
  - path = state_dir / "memory.jsonl"
  - records = read_records(path)
  - retention_days = config.retention_days if config else 90
  - max_n = max_matches if max_matches is not None else (config.max_matches if config else 3)
  - Filter: within_retention(r, retention_days) and repo_matches(r, repo)
  - For each record: compute path_overlap = path_match_score(paths, r.get("paths") or []) if paths
  - For fingerprint: match if fingerprint and (r.get("fingerprint") == fingerprint OR for verifier_cluster derive paths_hash and match record fingerprint prefix)
  - Include record if path_overlap > 0 OR fingerprint_matches
  - Attach path_overlap to record for sort
  - Sort by sort_key (severity, recency, path_overlap, id)
  - Slice [:max_n], map result_subset
  - Return list of dicts

Export query from booty.memory.__init__.py.

Create tests/test_memory_lookup.py with pytest tests:
- query empty paths and fingerprint -> []
- query with paths, no records -> []
- query with paths, matching record -> returns result subset
- query with fingerprint match
- sort order: severity, recency, path_overlap
- retention filter (record older than 90 days excluded)
- repo filter
- max_matches limit
  </action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -m pytest tests/test_memory_lookup.py -v</verify>
  <done>query() API works; tests pass; exported from memory</done>
</task>

</tasks>

<verification>
- MEM-15: query accepts paths, repo, sha; returns matches from 90 days
- MEM-16: path intersection OR fingerprint; verifier_cluster paths_hash when caller has paths
- MEM-17: sort severity desc, recency desc, path_overlap desc, id asc
- MEM-18: deterministic; use read_records + in-memory filter + sort (no embeddings)
</verification>

<success_criteria>
- Lookup API ready for Surfacing (Phase 25) and CLI (Phase 26)
- All lookup tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/24-lookup/24-01-SUMMARY.md`
</output>
