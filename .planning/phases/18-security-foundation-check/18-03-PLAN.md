---
phase: 18-security-foundation-check
plan: 03
type: execute
wave: 3
depends_on: ["18-02"]
files_modified:
  - src/booty/webhooks.py
  - src/booty/main.py
  - src/booty/config.py
autonomous: true

must_haves:
  truths:
    - "pull_request opened/synchronize/reopened enqueues SecurityJob to security_queue"
    - "Security runs on every PR (no is_agent_pr filter)"
    - "security_queue started in lifespan when security_enabled"
  artifacts:
    - path: src/booty/webhooks.py
      provides: Security enqueue in pull_request handler
    - path: src/booty/main.py
      provides: security_queue in app.state, lifespan
  key_links:
    - from: webhooks
      to: security
      via: security_queue.enqueue(SecurityJob)
      pattern: SecurityJob
---

<objective>
Wire pull_request webhook to Security and add security_queue to application lifespan.

Purpose: SEC-01 — Security runs on pull_request opened and synchronize (and reopened). Triggers Security pipeline for every PR.

Output: webhooks.py enqueues SecurityJob; main.py creates security_queue and starts workers.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-security-foundation-check/18-CONTEXT.md
@.planning/phases/18-security-foundation-check/18-RESEARCH.md
@src/booty/webhooks.py
@src/booty/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire pull_request to Security enqueue</name>
  <files>src/booty/webhooks.py</files>
  <action>
In github_webhook, inside the pull_request block (after Verifier enqueue block, before return), add Security enqueue logic:

1. security_queue = getattr(request.app.state, "security_queue", None)
2. If security_queue is not None and security_enabled(settings):
   - Check security_queue.is_duplicate(pr_number, head_sha) — if duplicate, continue (Security uses same dedup as Verifier conceptually but separate queue so separate dedup — each queue tracks its own. Per CONTEXT: dedup pr_number+head_sha. Security has its own queue so its own dedup set.)
   - Create SecurityJob with same payload fields: job_id=f"security-{pr_number}-{head_sha[:7]}", owner, repo_name, pr_number, head_sha, head_ref, repo_url, installation_id, payload
   - await security_queue.enqueue(job)
   - Log security_job_accepted

Security runs on EVERY PR — do not filter by is_agent_pr. Extract same repo/pr fields used for Verifier. Run Security enqueue in same request; both get 202 accepted. If Verifier is disabled, Security can still run (separate queues).
  </action>
  <verify>python -c "
from booty.webhooks import router
# Ensure webhook handler exists and pull_request logic paths are present
import booty.webhooks as m
import inspect
src = inspect.getsource(m.github_webhook)
assert 'security_queue' in src or 'SecurityJob' in src
"</verify>
  <done>pull_request events enqueue SecurityJob to security_queue</done>
</task>

<task type="auto">
  <name>Task 2: Add security_queue to lifespan</name>
  <files>src/booty/main.py</files>
  <action>
In main.py lifespan:
1. Add global security_queue variable
2. Import SecurityQueue, process_security_job (or _process_security_job wrapper)
3. If security_enabled(settings): create SecurityQueue(maxsize=100), await start_workers(SECURITY_WORKER_COUNT or 2, _process_security_job), set app.state.security_queue
4. Else: app.state.security_queue = None

Add SECURITY_WORKER_COUNT: int = 2 to config Settings (or reuse VERIFIER_WORKER_COUNT; CONTEXT says mirror Verifier — use separate SECURITY_WORKER_COUNT for flexibility, default 2).

Add _process_security_job wrapper that calls process_security_job(job, settings) and handles exceptions like _process_verifier_job.
  </action>
  <verify>python -c "
from booty.main import app
# App should have lifespan that would set security_queue
state = getattr(app, 'state', None) or type('State', (), {})()
# After lifespan runs, state would have security_queue — we can't easily run lifespan in test, but imports should work
from booty.security import SecurityQueue
assert SecurityQueue is not None
"</verify>
  <done>security_queue created and started in lifespan; app.state.security_queue set</done>
</task>
