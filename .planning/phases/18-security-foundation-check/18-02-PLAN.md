---
phase: 18-security-foundation-check
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/booty/security/__init__.py
  - src/booty/security/job.py
  - src/booty/security/queue.py
  - src/booty/security/runner.py
  - src/booty/github/checks.py
  - tests/test_security_runner.py
autonomous: true

must_haves:
  truths:
    - "SecurityJob and SecurityQueue mirror Verifier patterns (pr_number+head_sha dedup)"
    - "create_security_check_run creates booty/security check with queued status"
    - "process_security_job: create check -> in_progress -> load config -> completed success"
  artifacts:
    - path: src/booty/security/
      provides: SecurityJob, SecurityQueue, process_security_job
    - path: src/booty/github/checks.py
      provides: create_security_check_run
  key_links:
    - from: security/runner
      to: github/checks
      via: create_security_check_run
      pattern: create_security_check_run
---

<objective>
Create Security module skeleton: job, queue, Checks API integration, runner.

Purpose: SEC-02, SEC-15 — booty/security check published; queued → in_progress → completed lifecycle. Phase 18 baseline: minimal pipeline — create check, in_progress, load config, complete success with generic title "Security check complete".

Output: security/job.py, security/queue.py, security/runner.py, github/checks.create_security_check_run, tests.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-security-foundation-check/18-CONTEXT.md
@.planning/phases/18-security-foundation-check/18-RESEARCH.md
@src/booty/verifier/job.py
@src/booty/verifier/queue.py
@src/booty/verifier/runner.py
@src/booty/github/checks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SecurityJob and SecurityQueue</name>
  <files>src/booty/security/job.py, src/booty/security/queue.py, src/booty/security/__init__.py</files>
  <action>
Create src/booty/security/ directory. Add job.py with SecurityJob dataclass mirroring VerifierJob: job_id, owner, repo_name, pr_number, head_sha, head_ref, repo_url, installation_id, payload. (No is_agent_pr or issue_number — Security runs on every PR.)

Add queue.py with SecurityQueue class mirroring VerifierQueue: is_duplicate(pr_number, head_sha), mark_processed, enqueue, worker, start_workers, shutdown. Use same dedup key pattern pr_number:head_sha.

Add __init__.py exporting SecurityJob, SecurityQueue.
  </action>
  <verify>python -c "
from booty.security import SecurityJob, SecurityQueue
j = SecurityJob(job_id='sec-1', owner='o', repo_name='r', pr_number=1, head_sha='abc', head_ref='main', repo_url='https://x', installation_id=1, payload={})
assert j.pr_number == 1
q = SecurityQueue(maxsize=10)
assert not q.is_duplicate(1, 'abc')
"</verify>
  <done>SecurityJob and SecurityQueue exist and mirror Verifier patterns</done>
</task>

<task type="auto">
  <name>Task 2: Add create_security_check_run and security_enabled</name>
  <files>src/booty/github/checks.py, src/booty/config.py</files>
  <action>
In config.py add security_enabled(settings: Settings) -> bool. Reuse same condition as verifier_enabled: GITHUB_APP_ID and GITHUB_APP_PRIVATE_KEY configured (Security uses same GitHub App for Checks API).

In github/checks.py add create_security_check_run with same signature as create_check_run but name="booty/security", default output {"title": "Booty Security", "summary": "Queued"}. Reuse get_verifier_repo (or add get_security_repo that does the same — both use same App). Use security_enabled instead of verifier_enabled when checking.

Also add edit_security_check_run or reuse edit_check_run (it takes check_run object, works for any check). No new edit function needed — edit_check_run is generic.
  </action>
  <verify>python -c "
from booty.github.checks import create_security_check_run
# Will fail without real creds but import and signature should work
import inspect
sig = inspect.signature(create_security_check_run)
assert 'head_sha' in sig.parameters
"</verify>
  <done>create_security_check_run exists; security_enabled in config</done>
</task>

<task type="auto">
  <name>Task 3: Implement process_security_job runner</name>
  <files>src/booty/security/runner.py, tests/test_security_runner.py</files>
  <action>
Create security/runner.py with process_security_job(job: SecurityJob, settings: Settings) -> None.

Flow:
1. If not security_enabled(settings), log and return
2. create_security_check_run with status="queued", output title "Booty Security" or "Security", summary "Queued"
3. edit_check_run to status="in_progress", output title same, summary "Scanning for secrets and vulnerabilities…" (per CONTEXT)
4. Load config: fetch .booty.yml from repo at job.head_sha via GitHub API (like Verifier), load_booty_config_from_content. If BootyConfigV1 and security block present, apply_security_env_overrides. If security is None or security.enabled is False, complete with success and summary "Security check complete — disabled".
5. Otherwise (Security enabled): complete with success, title "Security check complete" or "Security OK", summary "Security check complete — no scanners configured" (Phase 18 baseline — no actual scanning yet).

Use get_verifier_repo (or equivalent) for repo access — same auth. Handle MissingFile/UnknownObjectException for no .booty.yml: treat as Security enabled (default per CONTEXT).
  </action>
  <verify>pytest tests/test_security_runner.py -v 2>/dev/null || python -c "
from booty.security.runner import process_security_job
# Basic import and structure check
assert callable(process_security_job)
"</verify>
  <done>process_security_job creates check, transitions queued->in_progress->completed success</done>
</task>
