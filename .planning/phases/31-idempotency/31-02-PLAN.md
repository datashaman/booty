---
phase: 31-idempotency
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/booty/planner/worker.py
  - src/booty/cli.py
autonomous: true

must_haves:
  truths:
    - Worker checks cache before generate_plan; cache hit skips LLM, reuses plan, updates comment
    - CLI plan_issue checks cache before generate_plan; cache hit skips LLM, updates comment
    - On save, plan metadata includes created_at, input_hash, plan_hash
  artifacts:
    - path: src/booty/planner/worker.py
      provides: process_planner_job with cache-before-generate
    - path: src/booty/cli.py
      provides: plan_issue with cache-before-generate
  key_links:
    - from: worker.process_planner_job
      to: cache.find_cached_issue_plan, cache.input_hash
      via: normalize → input_hash → find_cached → if hit use cached else generate
    - from: worker save_plan
      to: plan metadata
      via: merge metadata (created_at, input_hash, plan_hash) before save
---

<objective>
Wire issue-based planner (worker and CLI plan_issue) to check cache before LLM. On cache hit, reuse plan and update comment. On save, always add metadata (created_at, input_hash, plan_hash).

Purpose: Same issue with unchanged inputs within 24h returns cached plan without LLM call.
Output: worker.py and cli.py plan_issue use cache; plan metadata populated on save.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-idempotency/31-CONTEXT.md
@.planning/phases/31-idempotency/31-RESEARCH.md
@src/booty/planner/worker.py
@src/booty/cli.py
@src/booty/planner/cache.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Worker cache integration</name>
  <files>src/booty/planner/worker.py</files>
  <action>
Modify process_planner_job:

1. After inp = normalize_from_job(...), compute h = input_hash(inp).
2. ttl = float(os.environ.get("PLANNER_CACHE_TTL_HOURS", "24"))
3. cached = find_cached_issue_plan(job.owner, job.repo, job.issue_number, h, ttl)
4. If cached:
   - plan = cached
   - Log "planner_cache_hit" with job_id, issue_number
5. Else:
   - plan = generate_plan(inp)
   - risk_level, _ = classify_risk_from_paths(plan.touch_paths)
   - plan = plan.model_copy(update={"risk_level": risk_level})

6. Before save_plan: Build metadata dict with created_at (datetime.now(timezone.utc).isoformat()), input_hash=h, plan_hash=plan_hash(plan). Merge with plan.metadata (plan.metadata | new_metadata), then plan = plan.model_copy(update={"metadata": merged}).
7. save_plan(plan, path)
8. Post comment (same as today — format_plan_comment + post_plan_comment). post_plan_comment already find-and-edits; cache hit will update existing comment.

Import: input_hash, plan_hash, find_cached_issue_plan from booty.planner.cache.
</action>
  <verify>pytest tests/ -v -k "planner" --ignore=tests/e2e/ 2>/dev/null | tail -20</verify>
  <done>Worker checks cache; on hit skips LLM; plan metadata populated; comment posted/updated</done>
</task>

<task type="auto">
  <name>Task 2: CLI plan_issue cache integration</name>
  <files>src/booty/cli.py</files>
  <action>
Modify plan_issue in cli.py:

1. After inp = normalize_github_issue(...), before generate_plan:
   - h = input_hash(inp)
   - ttl = float(os.environ.get("PLANNER_CACHE_TTL_HOURS", "24"))
   - cached = find_cached_issue_plan(owner, repo_slug, issue_number, h, ttl)
   - If cached: plan_obj = cached
   - Else: plan_obj = generate_plan(inp); risk_level, _ = classify_risk_from_paths(plan_obj.touch_paths); plan_obj = plan_obj.model_copy(update={"risk_level": risk_level})

2. Before save_plan: Merge metadata (created_at, input_hash, plan_hash) same as worker. plan_obj = plan_obj.model_copy(update={"metadata": ...})

3. save_plan(plan_obj, path)
4. post_plan_comment as today
5. Output line unchanged (path | goal_snippet | steps | risk_level). Per CONTEXT: no "cache hit" indication in issue — cache is implementation detail. CLI output can remain as-is (or optionally add "(cached)" — CONTEXT says GitHub: no indication; CLI: "(cached, created at …)" for plan_text. For plan_issue, CONTEXT says "Cache hit behavior — GitHub: Update existing comment when cache hit... No new comment; no 'cache hit' indication in issue". So plan_issue is GitHub flow — no cache indication. Keep output same.
</action>
  <verify>booty plan --issue 1 --repo owner/repo 2>/dev/null (with valid token) or python -c "from booty.cli import plan; print('CLI imports OK')"</verify>
  <done>CLI plan_issue checks cache; on hit skips LLM; metadata populated; comment updated</done>
</task>

</tasks>

<verification>
- Worker and CLI both check cache before generate_plan
- Metadata (created_at, input_hash, plan_hash) present in saved plan
- post_plan_comment updates existing comment on cache hit (already does find-and-edit)
</verification>

<success_criteria>
- Issue-based planner uses cache within TTL
- Unchanged inputs return cached plan, no LLM call
- plan_hash in metadata for dedup
</success_criteria>

<output>
After completion, create `.planning/phases/31-idempotency/31-02-SUMMARY.md`
</output>
