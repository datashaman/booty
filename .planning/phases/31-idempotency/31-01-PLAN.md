---
phase: 31-idempotency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/planner/schema.py
  - src/booty/planner/store.py
  - src/booty/planner/cache.py
  - src/booty/planner/input.py
  - tests/test_planner_cache.py
autonomous: true

must_haves:
  truths:
    - Plan schema supports metadata (created_at, input_hash, plan_hash)
    - input_hash(PlannerInput) produces deterministic hash from canonical form
    - plan_hash(Plan) produces deterministic hash excluding metadata
    - load_plan(path) loads Plan from JSON or returns None
    - find_cached_issue_plan returns cached plan when input matches and within TTL
  artifacts:
    - path: src/booty/planner/schema.py
      provides: Plan with optional metadata field
    - path: src/booty/planner/cache.py
      provides: input_hash, plan_hash, is_plan_fresh, find_cached_issue_plan
    - path: src/booty/planner/store.py
      provides: load_plan
  key_links:
    - from: cache.input_hash
      to: input.PlannerInput
      via: canonical dict from goal, body, labels, source_type, incident_fields, default_branch
    - from: store.save_plan
      to: cache metadata merge
      via: caller enriches plan with metadata before save
---

<objective>
Add cache primitives for Phase 31 idempotency: schema metadata, input_hash, plan_hash, load_plan, TTL check, and find_cached_issue_plan.

Purpose: Foundation for cache-before-LLM flow. Same input within TTL returns cached plan.
Output: schema.py metadata field; cache.py with hashing and lookup; store.py load_plan.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-idempotency/31-CONTEXT.md
@.planning/phases/31-idempotency/31-RESEARCH.md
@src/booty/planner/schema.py
@src/booty/planner/store.py
@src/booty/planner/input.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema metadata and cache primitives</name>
  <files>src/booty/planner/schema.py, src/booty/planner/cache.py</files>
  <action>
1. In schema.py: Add `metadata: dict = Field(default_factory=dict)` to Plan model. Preserve extra="forbid" for top-level fields; metadata is an allowlisted dict for created_at, input_hash, plan_hash.

2. Create src/booty/planner/cache.py:
   - input_hash(inp: PlannerInput) -> str: Build canonical dict per RESEARCH (goal, body, sorted labels, source_type, incident_fields if present, default_branch from repo_context if present). Exclude metadata. json.dumps(..., sort_keys=True, separators=(",", ":")). hashlib.sha256(canon.encode()).hexdigest().
   - plan_hash(plan: Plan) -> str: plan.model_dump(), exclude metadata and created_at (and any run-specific keys). json.dumps(..., sort_keys=True, separators=(",", ":")). hashlib.sha256(...).hexdigest().
   - is_plan_fresh(created_at: datetime, ttl_hours: float = 24) -> bool: created_at and now must be UTC-aware. now - timedelta(hours=ttl_hours) <= created_at.

3. In store.py: Add load_plan(path: Path) -> Plan | None. If not path.exists(), return None. Open, json.load, Plan.model_validate. Catch JSONDecodeError and ValidationError, return None.
</action>
  <verify>python -c "
from booty.planner.input import PlannerInput
from booty.planner.cache import input_hash, plan_hash, is_plan_fresh
from booty.planner.schema import Plan, Step, HandoffToBuilder
from datetime import datetime, timezone, timedelta
inp = PlannerInput(goal='x', body='y', labels=['a','b'])
h1 = input_hash(inp)
h2 = input_hash(PlannerInput(goal='x', body='y', labels=['b','a']))
assert h1 == h2, 'labels order must not affect hash'
now = datetime.now(timezone.utc)
assert is_plan_fresh(now, 24)
assert not is_plan_fresh(now - timedelta(hours=25), 24)
p = Plan(goal='g', steps=[Step(id='P1', action='read', path='x', acceptance='d')], handoff_to_builder=HandoffToBuilder(branch_name_hint='b', commit_message_hint='c', pr_title='t', pr_body_outline='o'))
assert len(plan_hash(p)) == 64
print('OK')
"</verify>
  <done>input_hash deterministic for same canonical input; plan_hash excludes metadata; is_plan_fresh works; load_plan exists</done>
</task>

<task type="auto">
  <name>Task 2: find_cached_issue_plan</name>
  <files>src/booty/planner/cache.py</files>
  <action>
Add find_cached_issue_plan(owner: str, repo: str, issue_number: int, input_hash: str, ttl_hours: float = 24, state_dir: Path | None = None) -> Plan | None to cache.py.

Logic:
1. path = plan_path_for_issue(owner, repo, issue_number, state_dir)
2. plan = load_plan(path)
3. If not plan: return None
4. stored_hash = plan.metadata.get("input_hash")
5. If stored_hash != input_hash: return None
6. created_str = plan.metadata.get("created_at")
7. If not created_str: return None
8. created = datetime.fromisoformat(created_str.replace("Z", "+00:00"))
9. If not is_plan_fresh(created, ttl_hours): return None
10. Return plan

Use PLANNER_CACHE_TTL_HOURS env for default ttl_hours when not passed (e.g. float(os.environ.get("PLANNER_CACHE_TTL_HOURS", "24"))).
</action>
  <verify>pytest tests/test_planner_cache.py -v -k "find_cached" 2>/dev/null || python -c "
from pathlib import Path
import tempfile, os
from booty.planner.cache import find_cached_issue_plan
from booty.planner.store import plan_path_for_issue, save_plan
from booty.planner.schema import Plan, Step, HandoffToBuilder
from datetime import datetime, timezone
with tempfile.TemporaryDirectory() as d:
    os.environ['PLANNER_STATE_DIR'] = d
    path = plan_path_for_issue('o','r',1)
    path.parent.mkdir(parents=True, exist_ok=True)
    p = Plan(goal='g', steps=[Step(id='P1', action='read', path='x', acceptance='d')], handoff_to_builder=HandoffToBuilder(branch_name_hint='b', commit_message_hint='c', pr_title='t', pr_body_outline='o'), metadata={'input_hash':'abc123','created_at':datetime.now(timezone.utc).isoformat()})
    save_plan(p, path)
    cached = find_cached_issue_plan('o','r',1,'abc123',24)
    assert cached is not None
    assert find_cached_issue_plan('o','r',1,'wrong',24) is None
    print('OK')
"
</verify>
  <done>find_cached_issue_plan returns plan when input_hash matches and within TTL; returns None otherwise</done>
</task>

<task type="auto">
  <name>Task 3: Tests</name>
  <files>tests/test_planner_cache.py</files>
  <action>
Create tests/test_planner_cache.py:
1. test_input_hash_deterministic — same PlannerInput yields same hash; sorted labels
2. test_input_hash_excludes_metadata — metadata changes don't affect hash
3. test_plan_hash_excludes_metadata — plan_hash ignores metadata, created_at
4. test_load_plan_missing_returns_none
5. test_load_plan_invalid_returns_none
6. test_find_cached_issue_plan_hit — stored plan with matching input_hash and fresh
7. test_find_cached_issue_plan_miss_input_hash
8. test_find_cached_issue_plan_miss_expired
</action>
  <verify>pytest tests/test_planner_cache.py -v</verify>
  <done>All cache unit tests pass</done>
</task>

</tasks>

<verification>
- input_hash, plan_hash, load_plan, find_cached_issue_plan importable
- Plan schema has metadata field; save/load round-trip preserves it
- TTL uses UTC
</verification>

<success_criteria>
- Plan metadata field added
- cache.py provides input_hash, plan_hash, load_plan, is_plan_fresh, find_cached_issue_plan
- store.py has load_plan
- Tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-idempotency/31-01-SUMMARY.md`
</output>
