---
phase: 31-idempotency
plan: 03
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/booty/planner/store.py
  - src/booty/planner/cache.py
  - src/booty/cli.py
  - tests/test_planner_cache.py
autonomous: true

must_haves:
  truths:
    - Ad-hoc plan lookup uses hash index; same input returns cached plan within TTL
    - Ad-hoc saves to timestamped path; index maps input_hash to latest path
    - CLI plan_text shows "(cached, created at …)" on cache hit
  artifacts:
    - path: src/booty/planner/cache.py
      provides: find_cached_ad_hoc_plan, save_ad_hoc_plan
    - path: src/booty/planner/store.py
      provides: plan_path_for_ad_hoc_from_input(inp) for new timestamped path
  key_links:
    - from: CLI plan_text
      to: find_cached_ad_hoc_plan
      via: input_hash(inp) -> lookup index -> load if fresh
    - from: cache
      to: store plan_path_for_ad_hoc
      via: path for ad-hoc-<ts>-<hash>.json
---

<objective>
Add ad-hoc plan cache: hash index for lookup, timestamped paths for history. Wire CLI plan_text to check cache before LLM; on hit show "(cached, created at …)".

Purpose: Same free-text input within 24h returns cached plan. Directory/cwd not part of key.
Output: Ad-hoc cache in cache.py; plan_path_for_ad_hoc updated; CLI plan_text integrated.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-idempotency/31-CONTEXT.md
@.planning/phases/31-idempotency/31-RESEARCH.md
@src/booty/planner/store.py
@src/booty/planner/cache.py
@src/booty/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ad-hoc cache storage and lookup</name>
  <files>src/booty/planner/store.py, src/booty/planner/cache.py</files>
  <action>
1. In store.py: Add plan_path_for_ad_hoc_from_input(inp: PlannerInput, state_dir: Path | None = None) -> Path. Returns state_dir/plans/ad-hoc/ad-hoc-{timestamp}-{input_hash[:8]}.json. Keeps existing plan_path_for_ad_hoc(text) for backward compat during migration, or deprecate if CLI is sole caller — check CLI: it uses plan_path_for_ad_hoc(text). For consistency, plan_path_for_ad_hoc_from_input(inp) uses input_hash(inp) for the hash portion. Timestamp: datetime.now(timezone.utc).strftime("%Y%m%d%H%M%S").

2. In cache.py:
   - Ad-hoc index path: state_dir/plans/ad-hoc/index.json. Format: {"input_hash": "ad-hoc-YYYYMMDDHHMMSS-abc12345.json"}
   - find_cached_ad_hoc_plan(input_hash: str, ttl_hours: float = 24, state_dir: Path | None = None) -> Plan | None: Load index, get path for input_hash, load_plan, check created_at and is_plan_fresh, return plan or None.
   - save_ad_hoc_plan(plan: Plan, inp: PlannerInput, state_dir: Path | None = None) -> Path: Get path from plan_path_for_ad_hoc_from_input(inp), save_plan(plan, path), update index[input_hash(inp)] = path.name, write index atomically.
</action>
  <verify>python -c "
from booty.planner.input import PlannerInput
from booty.planner.cache import input_hash, find_cached_ad_hoc_plan, save_ad_hoc_plan
from booty.planner.schema import Plan, Step, HandoffToBuilder
import tempfile, os
from pathlib import Path
inp = PlannerInput(goal='x', body='y', labels=[])
p = Plan(goal='g', steps=[Step(id='P1', action='read', path='x', acceptance='d')], handoff_to_builder=HandoffToBuilder(branch_name_hint='b', commit_message_hint='c', pr_title='t', pr_body_outline='o'))
with tempfile.TemporaryDirectory() as d:
    os.environ['PLANNER_STATE_DIR'] = d
    path = save_ad_hoc_plan(p, inp)
    assert path.exists()
    cached = find_cached_ad_hoc_plan(input_hash(inp), 24)
    assert cached is not None
    print('OK')
"
</verify>
  <done>Ad-hoc index and lookup work; save preserves history with timestamped paths</done>
</task>

<task type="auto">
  <name>Task 2: CLI plan_text cache integration</name>
  <files>src/booty/cli.py</files>
  <action>
Modify plan_text in cli.py:

1. After inp = normalize_cli_text(...), before generate_plan:
   - h = input_hash(inp)
   - ttl = float(os.environ.get("PLANNER_CACHE_TTL_HOURS", "24"))
   - cached = find_cached_ad_hoc_plan(h, ttl)
   - If cached:
     - plan_obj = cached
     - created_at = cached.metadata.get("created_at", "")
     - cache_hint = f\" (cached, created at {created_at})\" if created_at else \" (cached)\"
   - Else:
     - plan_obj = generate_plan(inp)
     - risk_level, _ = classify_risk_from_paths(plan_obj.touch_paths)
     - plan_obj = plan_obj.model_copy(update={"risk_level": risk_level})
     - cache_hint = ""

2. Merge metadata (created_at, input_hash, plan_hash) before save. Use save_ad_hoc_plan(plan_obj, inp) instead of plan_path_for_ad_hoc + save_plan.

3. Output: click.echo(f\"{path} | {goal_snippet} | {len(plan_obj.steps)} steps | {risk_level}{cache_hint}\")

Import: input_hash, find_cached_ad_hoc_plan, save_ad_hoc_plan from booty.planner.cache.
</action>
  <verify>booty plan text "fix login" 2>/dev/null (runs); second run with same text shows "(cached, created at …)"</verify>
  <done>CLI plan_text checks ad-hoc cache; on hit shows cached hint; saves via save_ad_hoc_plan</done>
</task>

<task type="auto">
  <name>Task 3: Ad-hoc cache tests</name>
  <files>tests/test_planner_cache.py</files>
  <action>
Add to tests/test_planner_cache.py:
1. test_find_cached_ad_hoc_plan_hit — save via save_ad_hoc_plan, find returns plan
2. test_find_cached_ad_hoc_plan_miss_hash
3. test_find_cached_ad_hoc_plan_miss_expired
4. test_ad_hoc_preserves_history — two saves with same input produce two files; index points to latest
</action>
  <verify>pytest tests/test_planner_cache.py -v</verify>
  <done>Ad-hoc cache tests pass</done>
</task>

</tasks>

<verification>
- Ad-hoc lookup uses input_hash, not directory
- Same text from different cwds returns same cached plan
- "(cached, created at …)" shown on CLI cache hit
</verification>

<success_criteria>
- Ad-hoc plan cache with hash index
- CLI plan_text uses cache; temporal awareness on hit
- PLAN-23, PLAN-24, PLAN-26 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/31-idempotency/31-03-SUMMARY.md`
</output>
