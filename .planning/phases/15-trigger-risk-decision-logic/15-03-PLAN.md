---
phase: 15-trigger-risk-decision-logic
plan: 03
type: execute
wave: 2
depends_on: ["01", "02"]
files_modified:
  - src/booty/webhooks.py
  - src/booty/release_governor/handler.py
  - src/booty/test_runner/config.py
  - src/booty/release_governor/__init__.py
  - tests/test_release_governor_handler.py
autonomous: true

must_haves:
  truths:
    - "Governor receives workflow_run when verification workflow completes on main"
    - "Uses head_sha from payload (never latest main)"
    - "Idempotency: (repo, head_sha) dedup via delivery cache"
    - "Handler computes risk, decision; Phase 16 will act on outcome"
  artifacts:
    - path: src/booty/release_governor/handler.py
      provides: handle_workflow_run full pipeline
      min_lines: 80
    - path: src/booty/webhooks.py
      provides: workflow_run branch in /webhooks/github
  key_links:
    - from: webhooks.py
      to: handler.handle_workflow_run
      via: call when workflow_run + conclusion=success
      pattern: handle_workflow_run
    - from: handler.py
      to: risk.compute_risk_class
      via: call with comparison
      pattern: compute_risk_class
    - from: handler.py
      to: decision.compute_decision
      via: call with risk, state, config
      pattern: compute_decision
---

<objective>
Implement workflow_run webhook route and handle_workflow_run handler (GOV-01, GOV-02, GOV-03).

Purpose: Governor runs when verify-main workflow completes; fetches diff, computes risk and decision. Phase 16 adds workflow_dispatch and HOLD/ALLOW UX.
Output: workflow_run in webhooks; handler with full pipeline; tests.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-trigger-risk-decision-logic/15-CONTEXT.md
@.planning/phases/15-trigger-risk-decision-logic/15-RESEARCH.md
@src/booty/webhooks.py
@src/booty/release_governor/handler.py
@src/booty/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add verification_workflow_name to config</name>
  <files>src/booty/test_runner/config.py</files>
  <action>
    Add to ReleaseGovernorConfig:
    - verification_workflow_name: str = "Verify main"
    - Add RELEASE_GOVERNOR_VERIFICATION_WORKFLOW_NAME env override
    - Matches verify-main.yml "name: Verify main"
  </action>
  <verify>grep "verification_workflow_name" src/booty/test_runner/config.py</verify>
  <done>Config has verification_workflow_name for workflow_run filtering</done>
</task>

<task type="auto">
  <name>Task 2: Add workflow_run branch to webhooks</name>
  <files>src/booty/webhooks.py</files>
  <action>
    In github_webhook, before "if event_type != 'issues'":
    - If event_type == "workflow_run":
      - Parse payload: action, workflow_run.conclusion, workflow_run.name, workflow_run.head_sha, repository
      - If action != "completed" or conclusion != "success": return {"status": "ignored", "reason": "workflow_not_success"}
      - Load booty config, get release_governor block. If not enabled: return {"status": "ignored", "reason": "governor_disabled"}
      - If workflow_run.name != config.verification_workflow_name: return {"status": "ignored", "reason": "not_verification_workflow"}
      - Check branch is main: workflow_run.head_branch or event.repository.default_branch - workflow_run has head_branch. Require head_branch == "main" (or configurable). GOV-01 says "on main".
      - Idempotency: state_dir = get_state_dir(), has_delivery_id(state_dir, repo_full_name, head_sha) -> return {"status": "already_processed"}
      - Call handle_workflow_run(payload)
      - Return JSONResponse(202, {"status": "accepted", "event": "workflow_run"})

    Add import for release_governor handler, store, config loading. Use existing config load from booty.
  </action>
  <verify>grep -A2 "workflow_run" src/booty/webhooks.py | head -15</verify>
  <done>workflow_run events trigger handler when verification succeeds on main</done>
</task>

<task type="auto">
  <name>Task 3: Implement handle_workflow_run</name>
  <files>src/booty/release_governor/handler.py</files>
  <action>
    Implement handle_workflow_run(payload: dict) -> Decision:

    1. Extract: head_sha = payload["workflow_run"]["head_sha"], repo = payload["repository"]
    2. Get repo full_name, load config (release_governor block), get state_dir
    3. Load release state: state = load_release_state(state_dir)
    4. production_sha = state.production_sha_current or state.production_sha_previous or head_sha (avoid compare with self; if both None use head_sha -> diff empty -> LOW)
    5. Get PyGithub repo: g = Github(settings.GITHUB_TOKEN), repo = g.get_repo(full_name)
    6. comparison = repo.compare(production_sha, head_sha)  # base=production, head=head_sha
    7. risk_class = compute_risk_class(comparison, config)
    8. Degraded: stub get_degraded_signal() -> None (unknown). In-process; future Sentry.
    9. Approval context: env_approved = os.environ.get("RELEASE_GOVERNOR_APPROVED", "").lower() in ("1","true","yes"). For label/comment: use repo.get_commit(head_sha) and GitHub API "List pull requests associated with a commit" - GET /repos/{owner}/{repo}/commits/{sha}/pulls. Check PR labels for config.approval_label; check issue comments for config.approval_command. If approval_mode includes label/comment, fetch PRs. Simplify: only check env for Phase 15 if label/comment lookup is complex; document TODO for Phase 16. CONTEXT says all three channels. Implement env; for label: get commit, use repo.get_commit(sha).get_pulls() if exists, else requests to /repos/{o}/{r}/commits/{sha}/pulls, filter merged to main, check labels. For comment: get issue comments from PR, search for approval_command substring.
    10. is_first_deploy = state.production_sha_current is None
    11. decision = compute_decision(head_sha, risk_class, config, state, state_dir, degraded=None, approval_context={...}, is_first_deploy=is_first_deploy)
    12. record_delivery_id when we would have "processed" - actually do this only when we ALLOW and trigger (Phase 16). For now, don't record - we're not dispatching. Phase 16 records on dispatch. So Phase 15: compute decision, log it, return. No delivery_id record yet (that's for deploy idempotency).
    13. Return decision

    Actually idempotency: we should not run the full pipeline twice for same webhook delivery. Use X-GitHub-Delivery. The job_queue is_duplicate uses delivery_id. We don't have a governor queue - we're doing sync. So we need to track "already processed this workflow_run" - use (repo, head_sha) in has_delivery_id? No - delivery_ids is for "we already triggered deploy". So different: we might want to process and get HOLD - we don't record. We only record when we ALLOW and dispatch. So for idempotency of "don't process same workflow_run twice": use delivery_id. Add governor_processed cache or reuse a set. Actually GitHub sends each webhook once per delivery - delivery_id is unique. If we get retry, same delivery_id. So we need to not process duplicate deliveries. Use job_queue.is_duplicate(delivery_id) - but that's for issues. We could add a governor_processed set keyed by delivery_id. Or use a separate cache file. Simplest: in-memory set delivery_ids_seen = set(), add delivery_id, skip if in set. Survives one process lifetime. For persistence: add governor_deliveries.json or extend delivery_ids to include "governor_processed" entries. Actually delivery_ids is (repo, sha) -> delivery_id. So if we see (repo, head_sha) and it's in delivery_ids, we already processed and potentially deployed. So has_delivery_id for (repo, head_sha) means skip - we already did something for this SHA. That works for "don't reprocess" - whether we allowed or held. So: check has_delivery_id before processing; if True, return. When do we record? When we complete processing - so we don't run again. Record at end of handle_workflow_run with a placeholder delivery_id (we don't have one from deploy - we have X-GitHub-Delivery). Actually delivery_ids key is repo:sha. Value is delivery_id. So we record (repo, head_sha) -> delivery_id so we know we processed. Good.
    14. At end: record_delivery_id(state_dir, repo_full_name, head_sha, delivery_id from request header)
    But we don't have request in handler - we have payload. The webhook has the request. So we need to pass delivery_id to handle_workflow_run, or have the webhook do record after call. Webhook: after handle_workflow_run, record_delivery_id(state_dir, full_name, head_sha, request.headers.get("X-GitHub-Delivery", ""))
    Good.
  </action>
  <verify>python -c "from booty.release_governor.handler import handle_workflow_run; print('OK')"</verify>
  <done>handle_workflow_run computes risk and decision; returns Decision</done>
</task>

<task type="auto">
  <name>Task 4: Add handler tests</name>
  <files>tests/test_release_governor_handler.py</files>
  <action>
    Create integration-style tests:
    - test_handle_workflow_run_returns_decision: Mock Github, comparison, config, state. Call handle_workflow_run with minimal payload. Assert returns Decision with outcome in (ALLOW, HOLD).
    - test_uses_head_sha_from_payload: Verify handler uses workflow_run.head_sha, not latest.
    - Use unittest.mock for PyGithub repo.compare, store load.

    Minimal payload: {"workflow_run": {"head_sha": "abc123", "head_branch": "main", ...}, "repository": {"full_name": "owner/repo"}}
  </action>
  <verify>pytest tests/test_release_governor_handler.py -v</verify>
  <done>Handler tests pass</done>
</task>

</tasks>

<verification>
- workflow_run webhook route added
- handle_workflow_run returns Decision
- Uses head_sha from payload
- pytest for handler passes
</verification>

<success_criteria>
- Governor receives workflow_run (GOV-01)
- Uses head_sha from payload (GOV-02)
- Idempotency via delivery cache
- Handler wired to risk + decision
</success_criteria>

<output>
After completion, create .planning/phases/15-trigger-risk-decision-logic/15-03-SUMMARY.md
</output>
