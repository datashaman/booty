---
phase: 04-self-modification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/booty/config.py
  - src/booty/self_modification/__init__.py
  - src/booty/self_modification/detector.py
  - src/booty/self_modification/safety.py
  - src/booty/test_runner/config.py
autonomous: true

must_haves:
  truths:
    - "Self-target detection correctly identifies when webhook repo matches Booty's own repo across HTTPS/SSH/case/.git variants"
    - "Self-target detection rejects forks (different owner, same repo name)"
    - "Settings include BOOTY_OWN_REPO_URL, BOOTY_SELF_MODIFY_ENABLED (default false), BOOTY_SELF_MODIFY_REVIEWER"
    - "BootyConfig includes protected_paths field with sensible defaults"
    - "Protected paths validation blocks changes to paths matching protected_paths patterns"
  artifacts:
    - path: "src/booty/self_modification/detector.py"
      provides: "is_self_modification function for URL comparison"
      contains: "def is_self_modification"
    - path: "src/booty/self_modification/safety.py"
      provides: "Protected path validation using PathRestrictor"
      contains: "def validate_changes_against_protected_paths"
    - path: "src/booty/config.py"
      provides: "Self-modification config settings"
      contains: "BOOTY_SELF_MODIFY_ENABLED"
    - path: "src/booty/test_runner/config.py"
      provides: "protected_paths field on BootyConfig"
      contains: "protected_paths"
  key_links:
    - from: "src/booty/self_modification/detector.py"
      to: "giturlparse"
      via: "URL normalization and component comparison"
      pattern: "giturlparse"
    - from: "src/booty/self_modification/safety.py"
      to: "src/booty/code_gen/security.py"
      via: "PathRestrictor reuse for protected path enforcement"
      pattern: "PathRestrictor"
---

<objective>
Create the self-modification detection module and safety infrastructure: URL comparison for self-target detection, config settings for self-modification control, protected_paths in .booty.yml, and path validation using existing PathRestrictor.

Purpose: Foundation for self-modification — before Booty can safely modify itself, it needs to detect when it's targeting its own repo and enforce path protection boundaries.
Output: `src/booty/self_modification/` module with detector and safety components, extended Settings and BootyConfig.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-self-modification/04-RESEARCH.md
@.planning/phases/04-self-modification/04-CONTEXT.md

@src/booty/config.py
@src/booty/code_gen/security.py
@src/booty/test_runner/config.py
@src/booty/logging.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add giturlparse dependency and self-modification config settings</name>
  <files>pyproject.toml, src/booty/config.py</files>
  <action>
    1. Add `giturlparse` to the `dependencies` list in `pyproject.toml`.

    2. Extend `Settings` class in `src/booty/config.py` with three new fields:
       - `BOOTY_OWN_REPO_URL: str = ""` — empty means self-modification detection disabled
       - `BOOTY_SELF_MODIFY_ENABLED: bool = False` — explicit opt-in required
       - `BOOTY_SELF_MODIFY_REVIEWER: str = ""` — GitHub username for review requests on self-PRs

    Add a comment block `# Phase 4: Self-modification configuration` above the new fields, following the existing pattern of `# Phase 2: LLM Code Generation`.

    Run `pip install -e .` to verify dependency resolves.
  </action>
  <verify>
    - `pip install -e .` succeeds
    - `python -c "from booty.config import Settings; s = Settings(WEBHOOK_SECRET='x', TARGET_REPO_URL='y', ANTHROPIC_API_KEY='z'); print(s.BOOTY_SELF_MODIFY_ENABLED, s.BOOTY_OWN_REPO_URL)"` prints `False `
  </verify>
  <done>giturlparse installed, Settings has BOOTY_OWN_REPO_URL, BOOTY_SELF_MODIFY_ENABLED (default False), BOOTY_SELF_MODIFY_REVIEWER fields</done>
</task>

<task type="auto">
  <name>Task 2: Create self_modification module with detector and safety</name>
  <files>src/booty/self_modification/__init__.py, src/booty/self_modification/detector.py, src/booty/self_modification/safety.py, src/booty/test_runner/config.py</files>
  <action>
    1. Create `src/booty/self_modification/__init__.py` — empty init file.

    2. Create `src/booty/self_modification/detector.py` with:
       - `is_self_modification(webhook_repo_url: str, booty_own_repo_url: str) -> bool`:
         - Returns `False` immediately if `booty_own_repo_url` is empty (detection disabled)
         - Uses `giturlparse.parse()` and `giturlparse.validate()` for both URLs
         - Returns `False` with warning log if either URL is invalid
         - Compares `host`, `owner`, and `repo` components (all lowercased) — must match ALL THREE to prevent fork false positives
         - Logs the comparison result with owner/repo for debugging
         - Import `giturlparse` at the top of the file

    3. Extend `BootyConfig` in `src/booty/test_runner/config.py`:
       - Add `protected_paths: list[str]` field with default factory returning: `[".github/workflows/**", ".env", ".env.*", "**/*.env", "**/secrets.*", "Dockerfile", "docker-compose*.yml"]`
       - Add `@field_validator('protected_paths')` that ensures list is never empty — if empty, return minimum defaults `[".github/workflows/**", ".env", ".env.*"]`
       - Update `load_booty_config()`: when `.booty.yml` doesn't exist, instead of raising FileNotFoundError, return `BootyConfig(test_command="echo 'No tests configured'")` with default protected_paths. This allows self-modification to work on repos without .booty.yml (test runner will just echo). Keep the docstring explaining this change.

    4. Create `src/booty/self_modification/safety.py` with:
       - `create_self_modification_restrictor(workspace_path: Path) -> PathRestrictor`:
         - Loads `.booty.yml` via `load_booty_config(workspace_path)` (which now returns defaults if missing)
         - Creates `PathRestrictor(workspace_root=workspace_path, denylist_patterns=config.protected_paths)`
         - Logs protected paths count
       - `validate_changes_against_protected_paths(changes: list[dict], workspace_path: Path) -> tuple[bool, str | None]`:
         - Creates restrictor via `create_self_modification_restrictor()`
         - Validates each change's `"path"` key against restrictor
         - Returns `(True, None)` if all allowed, `(False, reason)` on first violation
         - Logs violations as warnings

    Use structlog logger from `booty.logging` in all new files.
  </action>
  <verify>
    - `python -c "from booty.self_modification.detector import is_self_modification; print(is_self_modification('https://github.com/datashaman/booty', 'git@github.com:datashaman/booty.git'))"` prints `True`
    - `python -c "from booty.self_modification.detector import is_self_modification; print(is_self_modification('https://github.com/otheruser/booty', 'https://github.com/datashaman/booty'))"` prints `False`
    - `python -c "from booty.self_modification.detector import is_self_modification; print(is_self_modification('https://github.com/datashaman/booty', ''))"` prints `False`
    - `python -c "from booty.self_modification.safety import validate_changes_against_protected_paths; print('OK')"` succeeds
    - `python -c "from booty.test_runner.config import BootyConfig; c = BootyConfig(test_command='pytest'); print(len(c.protected_paths) > 0)"` prints `True`
  </verify>
  <done>is_self_modification detects self-targeting across URL formats, rejects forks; BootyConfig has protected_paths; safety module validates changes against protected paths using PathRestrictor</done>
</task>

</tasks>

<verification>
- All imports work: `python -c "from booty.self_modification.detector import is_self_modification; from booty.self_modification.safety import validate_changes_against_protected_paths, create_self_modification_restrictor; print('All imports OK')"`
- `pip install -e .` succeeds (giturlparse resolves)
- Self-detection works across URL formats (HTTPS, SSH, .git suffix, case)
- Fork detection correctly rejects different owner
- Empty BOOTY_OWN_REPO_URL disables detection
- BootyConfig protected_paths has sensible defaults
- No circular imports between self_modification and existing modules
</verification>

<success_criteria>
- `src/booty/self_modification/` module exists with detector.py and safety.py
- giturlparse added to pyproject.toml dependencies
- Settings extended with 3 self-modification fields (all disabled by default)
- BootyConfig extended with protected_paths field
- is_self_modification correctly handles HTTPS/SSH/.git/case variations
- validate_changes_against_protected_paths blocks protected path modifications
</success_criteria>

<output>
After completion, create `.planning/phases/04-self-modification/04-01-SUMMARY.md`
</output>
