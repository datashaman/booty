---
phase: 21-permission-drift-governor-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/release_governor/override.py
  - src/booty/release_governor/handler.py
  - tests/test_release_governor_override.py
autonomous: true

must_haves:
  truths:
    - "Governor reads Security override for head_sha before compute_decision"
    - "When override present, risk_class=HIGH regardless of path-based computation"
    - "Governor polls up to 2 min for override when missing (race: Security may be slower)"
    - "Override entries pruned on read when older than 14 days"
  artifacts:
    - path: src/booty/release_governor/override.py
      provides: get_security_override, poll loop, prune expired
      contains: "security_overrides"
    - path: src/booty/release_governor/handler.py
      provides: Override check before compute_risk_class
  key_links:
    - from: handler.handle_workflow_run
      to: override.get_security_override_or_compute
      via: state_dir, repo_full_name, head_sha
      pattern: "get_security_override_with_poll"
    - from: override
      to: risk.compute_risk_class
      via: fallback when no override
      pattern: "compute_risk_class"
---

<objective>
Governor consumes Security risk override before deploy decisions. When Security has escalated (sensitive path touched), Governor uses risk_class=HIGH.

Purpose: SEC-10 — Governor reads Security override; deploy gating uses HIGH when present.
Output: override module (read+prune), handler integration, poll for race condition.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-permission-drift-governor-integration/21-CONTEXT.md
@.planning/phases/21-permission-drift-governor-integration/21-RESEARCH.md
@src/booty/release_governor/handler.py
@src/booty/release_governor/risk.py
@src/booty/release_governor/store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create override read module with poll and prune</name>
  <files>src/booty/release_governor/override.py</files>
  <action>
1. get_security_override(state_dir: Path, repo_full_name: str, sha: str) -> dict | None
   - Load security_overrides.json from state_dir (LOCK_SH)
   - Prune: remove entries with created_at older than 14 days; write back if any pruned (LOCK_EX)
   - Return entry for key f"{repo_full_name}:{sha}" or None
   - Return structure: {"risk_override": "HIGH", "reason": str, "paths": list, ...}
2. get_security_override_with_poll(state_dir, repo_full_name, sha, max_wait_sec: int = 120, interval_sec: float = 5.0) -> tuple[dict | None, Literal["LOW","MEDIUM","HIGH"]]
   - Poll get_security_override; if found, return (entry, "HIGH")
   - If not found, sleep interval_sec, retry; cap at max_wait_sec
   - When timeout: return (None, ...) — caller will use normal compute_risk_class
   - Actually: return (override_or_none, effective_risk). When override: (entry, "HIGH"). When timeout: (None, None) — caller uses compute_risk_class. Simplify: return override dict | None. Caller: if override: risk_class="HIGH"; else: risk_class=compute_risk_class(...)
3. Simplify: get_security_override(state_dir, repo, sha) -> dict | None. get_security_override_with_poll(...) -> dict | None. When poll returns None after timeout, caller uses compute_risk_class.
  </action>
  <verify>pytest tests/test_release_governor_override.py -v 2>/dev/null | tail -15</verify>
  <done>get_security_override returns entry or None; prune removes 14+ day entries; poll waits up to 2 min.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate override into handler and simulate</name>
  <files>src/booty/release_governor/handler.py</files>
  <action>
1. In handle_workflow_run:
   - After getting head_sha, repo_full_name, state_dir
   - Call override = get_security_override_with_poll(state_dir, repo_full_name, head_sha)
   - If override is not None: risk_class = "HIGH"
   - Else: risk_class = compute_risk_class(comparison, config)  # existing
   - Rest unchanged (compute_decision, etc.)
2. In simulate_decision_for_cli:
   - Same pattern: override = get_security_override_with_poll(state_dir, repo, head_sha)
   - If override: risk_class = "HIGH"; else: risk_class = compute_risk_class(...)
   - Note: simulate uses repo (owner/repo format), state_dir from arg or get_state_dir()
  </action>
  <verify>pytest tests/ -v -k "governor" --ignore=tests/e2e/ 2>/dev/null | tail -30</verify>
  <done>Governor uses HIGH when Security override present; otherwise computes risk normally.</done>
</task>

<task type="auto">
  <name>Task 3: Add override integration tests</name>
  <files>tests/test_release_governor_override.py</files>
  <action>
1. Test get_security_override returns None when file missing
2. Test get_security_override returns entry when key exists
3. Test get_security_override prunes expired entries (created_at > 14 days ago)
4. Test get_security_override_with_poll returns immediately when override present
5. Test get_security_override_with_poll returns None after timeout when override absent
6. Test handle_workflow_run / simulate use HIGH when override present (mock or integration)
  </action>
  <verify>pytest tests/test_release_governor_override.py -v 2>/dev/null</verify>
  <done>Override read, prune, and poll behavior covered by tests.</done>
</task>

</tasks>

<verification>
- Security override for repo:sha → Governor decision uses risk_class HIGH
- No override → Governor uses path-based compute_risk_class
- Expired overrides pruned on read
- Poll stops after 2 min when override never appears
</verification>

<success_criteria>
- SEC-10: Governor consumes Security risk override before deploy decisions
- Override present → risk_class HIGH
- Poll handles race (Governor before Security)
</success_criteria>

<output>
After completion, create `.planning/phases/21-permission-drift-governor-integration/21-02-SUMMARY.md`
</output>
