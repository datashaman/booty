---
phase: 21-permission-drift-governor-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/security/permission_drift.py
  - src/booty/security/override.py
  - src/booty/security/runner.py
  - tests/test_security_permission_drift.py
  - tests/test_security_override.py
autonomous: true

must_haves:
  truths:
    - "Sensitive path touched → ESCALATE (conclusion success, title 'Security escalated — workflow modified' or category)"
    - "Override persisted to security_overrides.json with risk_override=HIGH, reason=permission_surface_change"
    - "Renames checked: both old and new path matched against sensitive_paths"
    - "PR is not blocked — merge allowed on ESCALATE"
  artifacts:
    - path: src/booty/security/permission_drift.py
      provides: get_changed_paths, sensitive_paths_touched using PathSpec
      min_lines: 40
    - path: src/booty/security/override.py
      provides: persist_override, uses override store in state dir
      contains: "risk_override"
    - path: src/booty/security/runner.py
      provides: Permission drift check after audit, ESCALATE flow
  key_links:
    - from: runner.process_security_job
      to: permission_drift.sensitive_paths_touched
      via: get_changed_paths from workspace, match against config.sensitive_paths
      pattern: "sensitive_paths_touched"
    - from: runner
      to: override.persist_override
      via: repo_full_name, head_sha, paths
      pattern: "persist_override"
---

<objective>
Detect when sensitive paths are touched in a PR and ESCALATE (not FAIL). Persist risk override for Governor consumption.

Purpose: SEC-08, SEC-09, SEC-11 — sensitive path matching, ESCALATE behavior, override persistence.
Output: Permission drift module, override store, runner integration; check completes with success + "Security escalated — …" when sensitive paths touched.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-permission-drift-governor-integration/21-CONTEXT.md
@.planning/phases/21-permission-drift-governor-integration/21-RESEARCH.md
@src/booty/security/runner.py
@src/booty/release_governor/store.py
@src/booty/test_runner/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create permission_drift module</name>
  <files>src/booty/security/permission_drift.py</files>
  <action>
1. Create get_changed_paths(repo: git.Repo, base_sha: str, head_sha: str) -> list[tuple[str, str | None]]
   - Run repo.git.diff("--name-status", "-z", base_sha, head_sha)
   - Parse NUL-separated output; for R (rename) entries get both old and new path
   - Return list of (path, old_path_or_none) — for R, old_path is the first path, path is the second
2. Create sensitive_paths_touched(paths: list[tuple[str, str | None]], sensitive_paths: list[str]) -> list[str]
   - Build PathSpec.from_lines("gitwildmatch", sensitive_paths)
   - For each (path, old_path): if spec.match_file(path) or (old_path and spec.match_file(old_path)), add path (or old_path) to result
   - Return deduplicated list of touched sensitive paths
3. Create _title_for_paths(paths: list[str]) -> str
   - Map path prefix to category: .github/workflows/ -> "workflow modified", infra/ -> "infra modified", terraform/ -> "terraform modified", helm/ -> "helm modified", k8s/ -> "k8s modified", iam/ -> "iam modified", auth/ -> "auth modified", security/ -> "security modified"
   - Default "Security escalated — permission surface changed" if no specific match
   - Use first matching category for title
  </action>
  <verify>pytest tests/test_security_permission_drift.py -v 2>/dev/null | tail -15</verify>
  <done>get_changed_paths returns paths from diff; sensitive_paths_touched matches PathSpec; title mapping works.</done>
</task>

<task type="auto">
  <name>Task 2: Create override persistence module</name>
  <files>src/booty/security/override.py</files>
  <action>
1. Use get_state_dir() from booty.release_governor.store (shared with Governor)
2. persist_override(repo_full_name: str, sha: str, paths: list[str]) -> None
   - Key: f"{repo_full_name}:{sha}"
   - Payload: {"risk_override": "HIGH", "reason": "permission_surface_change", "sha": sha, "paths": paths, "created_at": iso8601 now}
   - Append/merge into security_overrides.json; use atomic write pattern from store._atomic_write_json
   - TTL: include created_at; prune expired (14 days) on read in Governor (this module only writes)
3. File: state_dir / "security_overrides.json"
4. Use fcntl LOCK_EX for write (same as store.save_release_state pattern)
5. Add test in tests/test_security_override.py: use tmp_path or monkeypatch RELEASE_GOVERNOR_STATE_DIR so persist_override writes to isolated dir; assert key and risk_override in file
  </action>
  <verify>pytest tests/test_security_override.py -v -k "persist" 2>/dev/null | tail -10</verify>
  <done>persist_override writes to security_overrides.json in state dir with correct schema.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate permission drift into runner</name>
  <files>src/booty/security/runner.py</files>
  <action>
After dependency audit passes (before final edit_check_run success):

1. Get base_sha from job.base_sha or payload; head_sha from job.head_sha
2. paths = get_changed_paths(workspace.repo, base_sha, head_sha)
3. If security_config: sensitive_paths = security_config.sensitive_paths; else use SecurityConfig default
4. touched = sensitive_paths_touched(paths, sensitive_paths)
5. If touched:
   - title = _title_for_paths(touched)
   - summary = "Paths that triggered escalation: " + ", ".join(sorted(touched)[:10]) + (" …" if len(touched) > 10 else "")
   - edit_check_run(check_run, status="completed", conclusion="success", output={"title": title, "summary": summary})
   - repo_full_name = f"{job.owner}/{job.repo_name}"
   - persist_override(repo_full_name, job.head_sha, touched)
   - logger.info("security_escalated", paths=touched)
   - return (do not continue to final success)
6. If not touched: proceed to existing final success (edit_check_run conclusion success)
  </action>
  <verify>pytest tests/ -v -k "security" --ignore=tests/e2e/ 2>/dev/null | tail -25</verify>
  <done>Sensitive path touch → ESCALATE (success + title); override persisted; PR not blocked.</done>
</task>

</tasks>

<verification>
- Sensitive path change in PR → booty/security check completes success with "Security escalated — workflow modified" (or category)
- security_overrides.json contains entry for repo:head_sha
- Rename of sensitive file triggers escalation
- No annotation on added/removed files (summary only per CONTEXT)
</verification>

<success_criteria>
- SEC-08: Sensitive paths matched (defaults from config)
- SEC-09: Touched → ESCALATE, override persisted
- SEC-11: PR not blocked (conclusion success)
</success_criteria>

<output>
After completion, create `.planning/phases/21-permission-drift-governor-integration/21-01-SUMMARY.md`
</output>
