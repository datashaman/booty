---
phase: 27-planner-foundation
plan: 03
type: execute
wave: 2
depends_on: ['01', '02']
files_modified:
  - src/booty/planner/jobs.py
  - src/booty/planner/worker.py
  - src/booty/webhooks.py
  - src/booty/main.py
autonomous: true

must_haves:
  truths:
    - Webhook returns 202 for issues.opened or issues.labeled when agent:plan in labels
    - PlannerJob enqueued to planner queue
    - Planner worker consumes job, produces minimal plan, stores to plans/<owner>/<repo>/<issue>.json
    - Unlabeled issues return 200, no enqueue
  artifacts:
    - path: src/booty/planner/jobs.py
      provides: PlannerJob dataclass
    - path: src/booty/planner/worker.py
      provides: process_planner_job, planner worker loop
    - path: src/booty/webhooks.py
      provides: agent:plan branch before Builder issues block
  key_links:
    - from: webhooks.py
      to: planner_queue.enqueue(PlannerJob)
      via: early return when agent:plan
      pattern: agent:plan|PlannerJob
    - from: worker
      to: planner/store.save_plan
      via: plan_path_for_issue
      pattern: save_plan|plan_path_for_issue
---

<objective>
GitHub webhook handles agent:plan; enqueue PlannerJob; worker produces minimal plan and stores.

Purpose: Issues with agent:plan trigger planner; 202 Accepted; async worker stores plan. Plan generation (LLM) is Phase 29 — worker produces skeleton plan.
Output: Webhook branch, PlannerJob, planner_queue, worker.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-planner-foundation/27-CONTEXT.md
@.planning/phases/27-planner-foundation/27-RESEARCH.md
@src/booty/webhooks.py
@src/booty/main.py
@src/booty/jobs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PlannerJob and planner queue</name>
  <files>src/booty/planner/jobs.py</files>
  <action>
Create planner/jobs.py. Define PlannerJob dataclass: job_id (str), issue_number (int), issue_url (str), repo_url (str), owner (str), repo (str), payload (dict). Mirror Job fields needed for plan storage. No state/error — worker handles.

Create planner_queue: asyncio.Queue and planner_processed_deliveries set for idempotency. Functions: planner_is_duplicate(delivery_id), planner_mark_processed(delivery_id), planner_enqueue(job: PlannerJob) -> bool. Cap processed at 10000 like JobQueue.
  </action>
  <verify>python -c "
from booty.planner.jobs import PlannerJob, planner_enqueue, planner_is_duplicate
import asyncio
async def t():
    j = PlannerJob(job_id='x', issue_number=1, issue_url='u', repo_url='r', owner='o', repo='r', payload={})
    ok = await planner_enqueue(j)
    assert ok
asyncio.run(t())
"</verify>
  <done>PlannerJob exists; planner_enqueue, planner_is_duplicate, planner_mark_processed work</done>
</task>

<task type="auto">
  <name>Task 2: Webhook agent:plan branch</name>
  <files>src/booty/webhooks.py</files>
  <action>
In github_webhook, add branch BEFORE the existing Builder issues block (which filters action=labeled, label=TRIGGER_LABEL).

When event_type == "issues":
  action = payload.get("action")
  issue = payload.get("issue", {})
  labels = [l.get("name") for l in issue.get("labels", [])]
  is_plan_trigger = (action == "opened" and "agent:plan" in labels) or (action == "labeled" and payload.get("label", {}).get("name") == "agent:plan")
  if is_plan_trigger:
      Check planner idempotency: if delivery_id and planner_is_duplicate(delivery_id), return {"status":"already_processed"}.
      Parse owner/repo from payload["repository"]["full_name"].
      Create PlannerJob(job_id=..., issue_number=issue["number"], issue_url=issue["html_url"], repo_url=repo["html_url"], owner=..., repo=..., payload=payload).
      planner_mark_processed(delivery_id), planner_enqueue(job).
      Return JSONResponse(status_code=202, content={"status":"accepted","event":"planner",...}).

When action not in (opened, labeled) or agent:plan not in labels: fall through to existing logic (Builder or ignore).
  </action>
  <verify>Manual or integration: POST /webhooks/github with issues payload, action=labeled, label=agent:plan -> 202</verify>
  <done>Webhook returns 202 for agent:plan on opened/labeled; enqueues PlannerJob</done>
</task>

<task type="auto">
  <name>Task 3: Planner worker and startup</name>
  <files>src/booty/planner/worker.py, src/booty/main.py</files>
  <action>
1. Create planner/worker.py. process_planner_job(job: PlannerJob) -> None: Build minimal Plan from issue (goal=issue["title"], steps=[], risk_level="LOW", touch_paths=[], handoff_to_builder with placeholder strings). Use plan_path_for_issue(job.owner, job.repo, job.issue_number). save_plan(plan, path). Log success.

2. Start planner worker in main.py: create asyncio.Task that loops on planner_queue.get(), calls process_planner_job, task_done(). Single worker for Phase 27. Start on lifespan startup, cancel on shutdown. Store planner_worker_task on app.state.
  </action>
  <verify>Enqueue PlannerJob via webhook or test; worker stores plan to plans/<owner>/<repo>/<issue>.json</verify>
  <done>Worker consumes queue, produces minimal plan, stores; main.py starts worker</done>
</task>

</tasks>

<verification>
- Webhook with agent:plan returns 202
- Planner worker stores plan JSON to correct path
- Unlabeled issues still flow to Builder or ignored correctly
</verification>

<success_criteria>
- GitHub webhook handles issue labeled agent:plan (and opened with agent:plan)
- 202 Accepted; planner runs async
- Plan stored to plans/<owner>/<repo>/<issue>.json
</success_criteria>

<output>
After completion, create .planning/phases/27-planner-foundation/27-03-SUMMARY.md
</output>
