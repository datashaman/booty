---
phase: 13-observability-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/config.py
  - src/booty/webhooks.py
autonomous: true

must_haves:
  truths:
    - "POST /webhooks/sentry accepts Sentry event_alert webhooks"
    - "Invalid or missing HMAC returns 401 with minimal body"
    - "Malformed payload missing required fields returns 422 with structured error"
    - "Alerts filtered by Sentry-Hook-Resource, severity threshold, dedup, cooldown"
  artifacts:
    - path: src/booty/webhooks.py
      provides: Sentry webhook route and verification
      min_lines: 50
    - path: src/booty/config.py
      provides: SENTRY_WEBHOOK_SECRET, OBSV_* settings
      contains: SENTRY_WEBHOOK_SECRET
  key_links:
    - from: src/booty/webhooks.py
      to: config.get_settings()
      via: SENTRY_WEBHOOK_SECRET, OBSV_MIN_SEVERITY, OBSV_COOLDOWN_HOURS
      pattern: get_settings\(\)|SENTRY_WEBHOOK_SECRET
---

<objective>
Add POST /webhooks/sentry route with HMAC-SHA256 verification, event_alert filtering, severity threshold, and in-memory dedup/cooldown by fingerprint (issue_id). Malformed payloads return 422; invalid signature returns 401. Filters low-severity alerts and prevents duplicate issues within cooldown window.

Purpose: OBSV-01, OBSV-02, OBSV-03, OBSV-04, OBSV-05 — webhook ingestion and filtering before issue creation.
Output: Working webhook route that accepts/validates Sentry alerts and passes filtered events to the issue creator (Plan 02).
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-observability-agent/13-CONTEXT.md
@.planning/phases/13-observability-agent/13-RESEARCH.md
@src/booty/webhooks.py
@src/booty/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add observability config and verify HMAC</name>
  <files>src/booty/config.py, src/booty/webhooks.py</files>
  <action>
1. In config.py add Settings fields:
   - SENTRY_WEBHOOK_SECRET: str  # Required, no default — fail startup if missing (per CONTEXT: no secret = no server)
   - OBSV_MIN_SEVERITY: str = "error"  # fatal, error, warning, info, debug — default error and above
   - OBSV_COOLDOWN_HOURS: float = 6.0
   Use dummy secret locally (e.g. "dev-dummy-secret") in .env — no dev exception for unverified webhooks.

2. In webhooks.py add verify_sentry_signature(payload_body: bytes, secret: str, sig_header: str | None) -> None:
   - Uses hmac.new(secret.encode("utf-8"), payload_body, hashlib.sha256).hexdigest()
   - Compares with hmac.compare_digest() to Sentry-Hook-Signature header (case-insensitive lookup)
   - Raises HTTPException(401) if missing or mismatch; use JSONResponse(401, {"error": "invalid_signature"}) in route handler so body matches CONTEXT

3. Add severity rank helper: def _severity_rank(level: str) -> int: return {"fatal":0,"error":1,"warning":2,"info":3,"debug":4}.get(level.lower(), 99)
   Filter pass when _severity_rank(event_level) <= _severity_rank(min_severity).
  </action>
  <verify>
# Signature verification
python -c "
from booty.webhooks import verify_sentry_signature
import hmac, hashlib
body = b'{\"action\":\"triggered\"}'
secret = 'test-secret'
sig = hmac.new(secret.encode(), body, hashlib.sha256).hexdigest()
verify_sentry_signature(body, secret, sig)  # no raise
"
# Missing sig raises
python -c "
from booty.webhooks import verify_sentry_signature
from fastapi import HTTPException
try: verify_sentry_signature(b'{}', 'x', None); assert False
except HTTPException as e: assert e.status_code == 401 and 'invalid' in str(e.detail).lower()
"
  </verify>
  <done>SENTRY_WEBHOOK_SECRET in Settings; verify_sentry_signature rejects missing/invalid signatures with 401.</done>
</task>

<task type="auto">
  <name>Task 2: Add POST /webhooks/sentry route with parse and filter</name>
  <files>src/booty/webhooks.py</files>
  <action>
1. Add @router.post("/sentry") async def sentry_webhook(request: Request):
   - Read raw body FIRST: payload_body = await request.body()
   - sig = request.headers.get("Sentry-Hook-Signature") or request.headers.get("sentry-hook-signature")
   - verify_sentry_signature(payload_body, settings.SENTRY_WEBHOOK_SECRET, sig)
   - payload = json.loads(payload_body)

2. Check Sentry-Hook-Resource: resource = request.headers.get("Sentry-Hook-Resource")
   - If resource != "event_alert": return {"status": "ignored", "reason": "not_event_alert"}

3. Validate payload structure: require payload.get("action") == "triggered", payload.get("data", {}).get("event")
   - data = payload.get("data", {}); event = data.get("event")
   - If missing event, event.issue_id, event.level: return JSONResponse(422, {"error": "invalid_payload", "missing": [...]})
   - Extract: issue_id = event.get("issue_id"), level = event.get("level", "error")

4. Severity filter: if _severity_rank(level) > _severity_rank(settings.OBSV_MIN_SEVERITY): return {"status": "ignored", "reason": "below_threshold"}

5. In-memory dedup + cooldown:
   - Module-level: _obsv_seen: dict[str, float] = {}  # issue_id -> last_created_ts
   - Now = time.time(); window_sec = settings.OBSV_COOLDOWN_HOURS * 3600
   - If issue_id in _obsv_seen and (now - _obsv_seen[issue_id]) < window_sec: return {"status": "ignored", "reason": "cooldown"}
   - Store/update: _obsv_seen[issue_id] = now (when we create issue in Plan 02; for now just pass through)
   - For Plan 01: if in cooldown return ignored; else we will defer issue creation to Plan 02 — add a placeholder: return {"status": "accepted", "issue_id": issue_id} for non-cooldown events. Actually: Plan 02 will add the issue creation. In Plan 01 we only implement the filter logic and return "accepted" for events that pass — but we don't create issues yet. So: if passes all filters, return {"status": "accepted", "issue_id": issue_id} and store in _obsv_seen. Plan 02 will replace the "accepted" path with actual issue creation. For Plan 01: just return accepted when passes; don't create issue. Cooldown: we need to record when we "accepted" (would create) — so _obsv_seen[issue_id] = now when we return accepted. Good.

6. Wire route in main.py: router already included at /webhooks, so /webhooks/sentry is auto-registered.
  </action>
  <verify>
# Route exists and responds
curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:8000/webhooks/sentry -H "Content-Type: application/json" -d '{}'
# Expect 401 (no signature)
# With invalid sig
curl -s -X POST http://localhost:8000/webhooks/sentry -H "Content-Type: application/json" -H "Sentry-Hook-Signature: invalid" -d '{}' | grep -q invalid
  </verify>
  <done>POST /webhooks/sentry exists; verifies HMAC; filters event_alert only; applies severity and cooldown; returns 401/422/200 appropriately.</done>
</task>

</tasks>

<verification>
- Route registered at /webhooks/sentry
- 401 on missing/invalid signature with {"error":"invalid_signature"}
- 422 on malformed payload (missing data.event, issue_id, level) with {"error":"invalid_payload","missing":[...]}
- 200 ignored for non-event_alert, below severity, or within cooldown
- 200 accepted for events that pass all filters
</verification>

<success_criteria>
1. POST /webhooks/sentry accepts JSON body
2. HMAC-SHA256 verification of Sentry-Hook-Signature before processing
3. event_alert only; severity filter (configurable min); cooldown per issue_id
4. Correct 401/422/200 responses
</success_criteria>

<output>
After completion, create `.planning/phases/13-observability-agent/13-01-SUMMARY.md`
</output>
