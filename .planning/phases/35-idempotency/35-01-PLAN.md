---
phase: 35-idempotency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/architect/cache.py
  - tests/test_architect_cache.py
autonomous: true

must_haves:
  truths:
    - "plan_hash for a Plan is deterministic (excludes metadata)"
    - "Architect cache lookup returns cached result when plan_hash matches and within TTL"
    - "Architect cache save stores approved/blocked outcomes with created_at"
  artifacts:
    - path: src/booty/architect/cache.py
      provides: find_cached_architect_result, save_architect_result, architect_plan_hash
      min_lines: 80
    - path: tests/test_architect_cache.py
      provides: Tests for cache hit/miss, TTL expiry, plan_hash
      min_lines: 100
  key_links:
    - from: booty/architect/cache.py
      to: booty/planner/cache.py
      via: import plan_hash, is_plan_fresh
      pattern: "from booty.planner.cache import"
---

<objective>
Implement Architect cache primitives: plan_hash (reuse), cache path, find_cached_architect_result, save_architect_result.

Purpose: ARCH-23, ARCH-24 â€” plan_hash and 24h cache for Architect outcomes.
Output: architect/cache.py with lookup/save; tests passing.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/35-idempotency/35-RESEARCH.md
@.planning/phases/35-idempotency/35-CONTEXT.md
@src/booty/planner/cache.py
@src/booty/architect/output.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create architect cache module</name>
  <files>src/booty/architect/cache.py</files>
  <action>
Create src/booty/architect/cache.py with:

1. architect_plan_hash(plan: Plan) -> str: Re-export or alias plan_hash from booty.planner.cache (same Plan schema, same exclusions). Use:
   from booty.planner.cache import plan_hash as architect_plan_hash
   (or def architect_plan_hash(plan): return plan_hash(plan) for explicit naming)

2. get_architect_cache_dir(state_dir: Path | None = None) -> Path:
   Use same base as Planner: state_dir or get_planner_state_dir() from booty.planner.store.
   Return state_dir / "architect". Create dir in save, not here.

3. _architect_cache_path(owner: str, repo: str, issue_number: int, plan_hash_val: str, state_dir: Path | None = None) -> Path:
   Return get_architect_cache_dir(state_dir) / owner / repo / str(issue_number) / f"{plan_hash_val}.json"

4. ArchitectCacheEntry dataclass or TypedDict:
   created_at: str (ISO UTC)
   approved: bool
   plan: dict | None  # Plan.model_dump() when approved
   architect_notes: str | None
   block_reason: str | None  # when approved=False

5. find_cached_architect_result(owner, repo, issue_number, plan_hash_val, ttl_hours=None, state_dir=None) -> ArchitectCacheEntry | None:
   - ttl = ttl_hours or float(os.environ.get("ARCHITECT_CACHE_TTL_HOURS", "24"))
   - path = _architect_cache_path(...)
   - Load JSON if exists; parse created_at; call is_plan_fresh(created, ttl) from planner.cache
   - Return ArchitectCacheEntry or None

6. save_architect_result(owner, repo, issue_number, plan_hash_val, approved, plan=None, architect_notes=None, block_reason=None, state_dir=None) -> Path:
   - created_at = datetime.now(timezone.utc).isoformat()
   - Build dict, write atomically via tempfile + os.replace (same as planner/store.save_plan)
   - path.parent.mkdir(parents=True, exist_ok=True)
</action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -c "
from booty.architect.cache import architect_plan_hash, find_cached_architect_result, save_architect_result
from booty.planner.schema import Plan, HandoffToBuilder
hbt = HandoffToBuilder(branch_name_hint='b', commit_message_hint='c', pr_title='t', pr_body_outline='o')
p = Plan(goal='x', steps=[], handoff_to_builder=hbt)
h = architect_plan_hash(p)
assert len(h) == 64
assert h == architect_plan_hash(p)
print('architect_plan_hash OK')
"</verify>
  <done>architect_plan_hash, find_cached_architect_result, save_architect_result exist; TTL from ARCHITECT_CACHE_TTL_HOURS</done>
</task>

<task type="auto">
  <name>Task 2: Add architect cache tests</name>
  <files>tests/test_architect_cache.py</files>
  <action>
Create tests/test_architect_cache.py:

1. test_architect_plan_hash_excludes_metadata: Create two Plan instances with same content but different metadata (created_at); assert hashes equal.

2. test_find_cached_architect_result_hit: Save approved result, find with same plan_hash and TTL; assert returns entry with approved=True, plan present.

3. test_find_cached_architect_result_miss_hash: Save for plan_hash A, find with plan_hash B; assert None.

4. test_find_cached_architect_result_miss_expired: Save with created_at in past (mock or write old timestamp); find with TTL; assert None.

5. test_save_architect_result_blocked: Save blocked result (approved=False, block_reason="X"); find; assert approved=False, block_reason="X".

Use tmp_path and ARCHITECT_CACHE_TTL_HOURS / state_dir for isolation. Follow test_planner_cache.py patterns.
</action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -m pytest tests/test_architect_cache.py -v</verify>
  <done>All 5 tests pass</done>
</task>

</tasks>

<verification>
- architect/cache.py imports from planner.cache (plan_hash, is_plan_fresh)
- Cache path: state_dir/architect/owner/repo/issue_number/plan_hash.json
- ARCHITECT_CACHE_TTL_HOURS env (default 24) used
- Atomic write via tempfile + os.replace
</verification>

<success_criteria>
- architect_plan_hash(plan) deterministic, excludes metadata
- find_cached_architect_result returns cached entry when hash matches and within TTL
- save_architect_result writes approved and blocked outcomes
- Tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/35-idempotency/35-01-SUMMARY.md`
</output>
