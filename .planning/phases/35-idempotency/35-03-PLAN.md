---
phase: 35-idempotency
plan: 03
type: execute
wave: 2
depends_on: ["01", "02"]
files_modified:
  - src/booty/main.py
autonomous: true

must_haves:
  truths:
    - "Architect cache hit (approved) reuses ArchitectPlan, enqueues Builder, updates comment only if changed"
    - "Architect cache hit (blocked) short-circuits, posts block comment only if changed"
    - "Architect cache miss runs full validation, saves result, updates comment"
  artifacts:
    - path: src/booty/main.py
      provides: Architect idempotency flow in _planner_worker_loop
  key_links:
    - from: main.py _planner_worker_loop
      to: booty.architect.cache
      via: architect_plan_hash, find_cached_architect_result, save_architect_result
      pattern: "from booty.architect.cache import"
    - from: main.py _planner_worker_loop
      to: booty.github.comments
      via: update_plan_comment_with_architect_section_if_changed
      pattern: "update_plan_comment_with_architect_section_if_changed"
---

<objective>
Integrate Architect cache into planner worker: cache check before validation, cache save after, diff-before-update for comments.

Purpose: ARCH-23, ARCH-24, ARCH-25 — full idempotency flow.
Output: main.py with cache short-circuit and comment diff.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/35-idempotency/35-RESEARCH.md
@.planning/phases/35-idempotency/35-CONTEXT.md
@src/booty/main.py
@src/booty/architect/cache.py
@src/booty/architect/output.py
@src/booty/github/comments.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cache check before Architect</name>
  <files>src/booty/main.py</files>
  <action>
In _planner_worker_loop, before calling process_architect_input:

1. Import architect_plan_hash, find_cached_architect_result, save_architect_result from booty.architect.cache
2. Import update_plan_comment_with_architect_section_if_changed from booty.github.comments
3. When architect_config is enabled (not should_enqueue_builder), compute:
   h = architect_plan_hash(result.plan)
   cached = find_cached_architect_result(job.owner, job.repo, job.issue_number, h)
4. If cached:
   - If cached.approved: Build ArchitectPlan from cached.plan (Plan.model_validate), architect_notes from cached
     - architect_plan = build_architect_plan(Plan.model_validate(cached.plan), cached.architect_notes)
     - architect_section = format_architect_section("approved", risk_level=architect_plan.risk_level, architect_notes=architect_plan.architect_notes)
     - Use update_plan_comment_with_architect_section_if_changed (not post_plan_comment, not update_plan_comment_with_architect_section directly)
     - If plan comment exists: update_plan_comment_with_architect_section_if_changed(...). If no plan comment (Planner posts it): we need to ensure plan is on comment. On cache hit, Planner already posted. So we only update architect section via if_changed.
     - should_enqueue_builder = True
   - Else (blocked): post_architect_blocked_comment with cached.block_reason. But CONTEXT says "diff first; update only if block differs". So use format_architect_section("blocked", reason=cached.block_reason), then update_plan_comment_with_architect_section_if_changed. Actually post_architect_blocked_comment creates/updates the block. We need the same diff behavior. Refactor: compute architect_section = format_architect_section("blocked", reason=cached.block_reason), call update_plan_comment_with_architect_section_if_changed. If that returns False (unchanged), we might still need to add architect-review label if missing? CONTEXT: "Block comment update: same as approval — diff first; update only if block differs". So we only update comment when different. Label agent:architect-review is applied on block — for cache hit we already blocked before, label might exist. Don't re-add if present. Keep it simple: update comment only if changed; don't touch labels on cache hit (they should already be there from first block).
   - Skip process_architect_input entirely.
5. If not cached: fall through to existing flow (process_architect_input).
</action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -c "
from booty.main import get_app
# Smoke: app loads, planner worker logic exists
app = get_app()
print('main imports OK')
"</verify>
  <done>Cache check before Architect; cache hit short-circuits</done>
</task>

<task type="auto">
  <name>Task 2: Save to cache on miss, use diff helper for comments</name>
  <files>src/booty/main.py</files>
  <action>
On Architect path (not cache hit), after process_architect_input:

1. Compute h = architect_plan_hash(arch_result.plan). Use Plan from arch_result (already validated).

2. If arch_result.approved:
   - save_architect_result(job.owner, job.repo, job.issue_number, h, approved=True,
       plan=arch_result.plan.model_dump(), architect_notes=arch_result.architect_notes)
   - architect_section = format_architect_section("approved", risk_level=..., architect_notes=...)
   - Replace post_plan_comment(body) with update_plan_comment_with_architect_section_if_changed(
       settings.GITHUB_TOKEN, job.repo_url, job.issue_number, architect_section)
   - Planner already posted the plan comment; Architect only adds/updates the booty-architect block.

3. If not arch_result.approved (blocked):
   - save_architect_result(job.owner, job.repo, job.issue_number, h, approved=False, block_reason=...)
   - architect_section = format_architect_section("blocked", reason=...)
   - If get_plan_comment_body(...) is not None: call update_plan_comment_with_architect_section_if_changed
   - Else: call post_architect_blocked_comment (fallback when no plan comment exists)
   - add_architect_review_label as currently done
</action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -c "from booty.main import get_app; get_app(); print('OK')"</verify>
  <done>Cache save on miss; diff-before-update for comments; blocked fallback preserved</done>
</task>

<task type="auto">
  <name>Task 3: Cache hit comment flow</name>
  <files>src/booty/main.py</files>
  <action>
On cache hit (cached = find_cached_architect_result(...) is not None):

1. If cached.approved:
   - architect_plan = build_architect_plan(Plan.model_validate(cached.plan), cached.architect_notes)
   - architect_section = format_architect_section("approved", risk_level=architect_plan.risk_level, architect_notes=architect_plan.architect_notes)
   - update_plan_comment_with_architect_section_if_changed(settings.GITHUB_TOKEN, job.repo_url, job.issue_number, architect_section)
   - should_enqueue_builder = True

2. If not cached.approved (blocked):
   - architect_section = format_architect_section("blocked", reason=cached.block_reason or "")
   - If get_plan_comment_body(...): update_plan_comment_with_architect_section_if_changed(...)
   - Else: post_architect_blocked_comment(..., reason=cached.block_reason)
   - Do NOT call add_architect_review_label on cache hit (label already applied from first block)
   - Do NOT enqueue Builder

3. Skip process_architect_input entirely when cached.
</action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -m pytest tests/ -v -k "architect or planner" --ignore=tests/e2e/ 2>/dev/null | tail -15</verify>
  <done>Cache hit reuses result; comment updated only if changed; no re-validation</done>
</task>

</tasks>

<verification>
- Cache check before process_architect_input
- save_architect_result called on both approved and blocked
- update_plan_comment_with_architect_section_if_changed used instead of unconditional update
- ARCH-23, ARCH-24, ARCH-25 satisfied
</verification>

<success_criteria>
- Same plan within 24h reuses cached ArchitectPlan or blocked result
- Comment updated only when booty-architect block differs
- No re-validation on cache hit
</success_criteria>

<output>
After completion, create `.planning/phases/35-idempotency/35-03-SUMMARY.md`
</output>
