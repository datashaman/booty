---
phase: 38-agent-pr-detection-event-wiring
plan: 03
type: execute
wave: 2
depends_on: ["38-01"]
files_modified:
  - src/booty/reviewer/runner.py
  - src/booty/main.py
  - src/booty/config.py
autonomous: true

must_haves:
  truths:
    - "process_reviewer_job creates check (queued), in_progress, completes with stub success"
    - "Worker loads .booty.yml; get_reviewer_config returns None → no-op (no check, no comment)"
    - "Check titles: Queued/In progress 'Booty Reviewer'; Success 'Reviewer approved' (stub)"
    - "reviewer_queue started in lifespan when verifier_enabled"
  artifacts:
    - path: src/booty/reviewer/runner.py
      provides: process_reviewer_job
      contains: "create_reviewer_check_run"
    - path: src/booty/main.py
      provides: reviewer_queue in lifespan
  key_links:
    - from: main.py lifespan
      to: reviewer
      via: reviewer_queue, _process_reviewer_job
      pattern: reviewer_queue|process_reviewer_job
---

<objective>
Create Reviewer runner stub and wire reviewer_queue into main.py lifespan.

Purpose: REV-04, REV-05 — Check run lifecycle (queued → in_progress → success); titles "Booty Reviewer" for queued/in progress, "Reviewer approved" for success stub. Worker no-ops when repo config disables Reviewer.
Output: reviewer/runner.py, main.py lifespan changes.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-agent-pr-detection-event-wiring/38-CONTEXT.md
@.planning/phases/38-agent-pr-detection-event-wiring/38-RESEARCH.md
@src/booty/github/checks.py
@src/booty/reviewer/config.py
@src/booty/verifier/runner.py
@src/booty/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: process_reviewer_job runner stub</name>
  <files>src/booty/reviewer/runner.py</files>
  <action>
Create src/booty/reviewer/runner.py:

async def process_reviewer_job(job: ReviewerJob, settings: Settings) -> None:
    """Process Reviewer job — Phase 38 stub: check lifecycle only. Phase 39 adds LLM."""

    1. Check cancel_event: if getattr(job, "cancel_event", None) and job.cancel_event.is_set(): return early
    2. check_run = create_reviewer_check_run(owner, repo_name, head_sha, installation_id, settings, status="queued", output={"title": "Booty Reviewer", "summary": "Queued for review…"})
    3. If check_run is None (App disabled): return
    4. edit_check_run(check_run, status="in_progress", output={"title": "Booty Reviewer", "summary": "In progress…"})
    5. Check cancel_event again
    6. Load .booty.yml: get_verifier_repo, repo.get_contents(".booty.yml", ref=head_sha), load_booty_config_from_content, get_reviewer_config
    7. If get_reviewer_config returns None: no-op, return (no check completion, no comment — per CONTEXT: worker decides based on config)
    8. config = apply_reviewer_env_overrides(config); if not config.enabled: no-op, return
    9. Check cancel_event again
    10. Stub: edit_check_run(check_run, status="completed", conclusion="success", output={"title": "Reviewer approved", "summary": "Review complete (stub). Phase 39 adds LLM."})

Use get_verifier_repo from checks (or booty.github.checks). Import create_reviewer_check_run, edit_check_run from booty.github.checks.
  </action>
  <verify>python -c "from booty.reviewer.runner import process_reviewer_job; print(process_reviewer_job.__name__)"</verify>
  <done>process_reviewer_job exists; creates check, loads config, no-ops when disabled, stub success</done>
</task>

<task type="auto">
  <name>Task 2: reviewer_queue and workers in lifespan</name>
  <files>src/booty/main.py, src/booty/config.py</files>
  <action>
Wire Reviewer into main.py lifespan:

1. config.py: Add REVIEWER_WORKER_COUNT: int = 2
2. main.py: Import ReviewerQueue, ReviewerJob, process_reviewer_job from booty.reviewer
3. Add global reviewer_queue variable
4. In lifespan, after Security queue block: if verifier_enabled(settings): create ReviewerQueue(maxsize=100), await start_workers(REVIEWER_WORKER_COUNT or 2, _process_reviewer_job), app.state.reviewer_queue = reviewer_queue. Else: reviewer_queue = None, app.state.reviewer_queue = None
5. Add _process_reviewer_job(job: ReviewerJob) wrapper: calls process_reviewer_job(job, get_settings()), same exception handling as _process_verifier_job (sentry, logger)

Reviewer uses same App credentials as Verifier, so create reviewer_queue when verifier_enabled.
  </action>
  <verify>python -c "from booty.main import app; from booty.reviewer.queue import ReviewerQueue; print(ReviewerQueue)"</verify>
  <done>reviewer_queue created in lifespan; workers process ReviewerJob</done>
</task>

<task type="auto">
  <name>Task 3: Worker cancel check and cleanup</name>
  <files>src/booty/reviewer/runner.py, src/booty/reviewer/queue.py</files>
  <action>
Ensure runner checks cancel_event and queue clears _cancel_events on worker completion:

1. In runner: at each phase boundary (after create_check_run, after in_progress, before final edit), check: if getattr(job, "cancel_event", None) and job.cancel_event.is_set(): edit_check_run(conclusion="cancelled" or "skipped"), return
2. In queue worker: after process_fn(job) completes (success or exception), clear _cancel_events for this job's (repo, pr). Use try/finally to ensure cleanup.

GitHub Checks API: conclusion can be "success", "failure", "cancelled", "skipped". Use "cancelled" when worker exits due to cancel.
  </action>
  <verify>grep -n "cancel_event\|cancelled" src/booty/reviewer/runner.py src/booty/reviewer/queue.py</verify>
  <done>Runner exits early on cancel; queue cleans up cancel events</done>
</task>

</tasks>

<verification>
- create_reviewer_check_run creates booty/reviewer check
- Check titles match REV-05: Queued/In progress "Booty Reviewer", Success "Reviewer approved"
- Worker no-ops when get_reviewer_config returns None
</verification>

<success_criteria>
- Reviewer runner stub completes check lifecycle
- reviewer_queue in app.state when verifier_enabled
</success_criteria>

<output>
After completion, create .planning/phases/38-agent-pr-detection-event-wiring/38-03-SUMMARY.md
</output>
