---
phase: 25-surfacing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/github/comments.py
  - src/booty/memory/surfacing.py
  - src/booty/webhooks.py
  - tests/test_memory_surfacing.py
autonomous: true

must_haves:
  truths:
    - "On Verifier check run completion: single updatable PR comment 'Memory: related history' (marker <!-- booty-memory -->)"
    - "Comment shows up to max_matches (configurable) items: type, date, summary, link per MEM-20"
    - "Zero matches → no comment posted (omit entirely)"
    - "Trigger: check_run event when booty/verifier completes; only when PR exists and comment_on_pr enabled"
  artifacts:
    - path: src/booty/github/comments.py
      provides: post_memory_comment
      contains: def post_memory_comment
    - path: src/booty/memory/surfacing.py
      provides: surface_pr_comment, format_matches_for_pr
      contains: def surface_pr_comment
    - path: src/booty/webhooks.py
      provides: check_run handler for booty/verifier
  key_links:
    - from: webhooks check_run
      to: memory.lookup.query
      via: surface_pr_comment
    - from: post_memory_comment
      to: _get_repo
      pattern: Find-or-edit by <!-- booty-memory -->
---

<objective>
Implement PR comment surfacing when Verifier check run completes. Single updatable "Memory: related history" comment per PR with up to max_matches (configurable). MEM-19, MEM-20.

Purpose: Surface memory context on Builder PRs after Verifier has run. Informational only (MEM-23).
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/25-surfacing/25-CONTEXT.md
@.planning/phases/25-surfacing/25-RESEARCH.md
@src/booty/github/comments.py
@src/booty/memory/lookup.py
@src/booty/memory/config.py
@src/booty/webhooks.py
@src/booty/github/checks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: post_memory_comment and format helper</name>
  <files>src/booty/github/comments.py</files>
  <action>
In src/booty/github/comments.py add:

1. post_memory_comment(github_token: str, repo_url: str, pr_number: int, body: str) -> None
   - Body must include marker "<!-- booty-memory -->" (HTML comment for reliable detection)
   - Title "## Memory: related history" at top
   - Find-or-edit pattern: issue.get_comments(), find comment containing "<!-- booty-memory -->", edit if found else create
   - Same _get_repo, try/except GithubException as post_verifier_failure_comment
   - Log memory_comment_posted / memory_comment_updated

2. Caller is responsible for not calling when body would be empty (zero matches). This function always posts if called.
  </action>
  <verify>python -c "
from booty.github.comments import post_memory_comment
import inspect
sig = inspect.signature(post_memory_comment)
params = list(sig.parameters)
assert params == ['github_token', 'repo_url', 'pr_number', 'body']
# Body construction includes marker
code = inspect.getsource(post_memory_comment)
assert 'booty-memory' in code
assert 'Memory: related history' in code
print('OK')
"</verify>
  <done>post_memory_comment exists; find-or-edit by marker</done>
</task>

<task type="auto">
  <name>Task 2: memory/surfacing.py — format and surface_pr_comment</name>
  <files>src/booty/memory/surfacing.py</files>
  <action>
Create src/booty/memory/surfacing.py:

1. format_matches_for_pr(matches: list[dict]) -> str
   - Each match has type, timestamp, summary, links, id (from lookup.result_subset)
   - Format per match: "- **{type}** ({date}) — {summary} {link}" — one line per match
   - Date: format timestamp as YYYY-MM-DD or readable; use first link if present
   - Return joined lines; empty matches -> ""

2. surface_pr_comment(
     github_token: str,
     repo_url: str,
     pr_number: int,
     paths: list[str],
     repo: str,
     mem_config: MemoryConfig,
     state_dir: Path | None = None,
   ) -> None
   - If not mem_config.comment_on_pr: return
   - matches = memory.lookup.query(paths=paths, repo=repo, config=mem_config, state_dir=state_dir)
   - If not matches: return (omit entirely per CONTEXT)
   - body = format_matches_for_pr(matches)
   - post_memory_comment(github_token, repo_url, pr_number, body)

3. Export from booty.memory.__init__.py
  </action>
  <verify>python -c "
from booty.memory.surfacing import format_matches_for_pr, surface_pr_comment
m = [{'type':'incident','timestamp':'2024-01-15T10:00:00Z','summary':'x','links':['https://a'],'id':'1'}]
s = format_matches_for_pr(m)
assert 'incident' in s and 'x' in s
assert callable(surface_pr_comment)
print('OK')
"</verify>
  <done>surfacing module formats matches and surfaces PR comment</done>
</task>

<task type="auto">
  <name>Task 3: check_run webhook handler</name>
  <files>src/booty/webhooks.py</files>
  <action>
In github_webhook, add branch BEFORE pull_request (so check_run is handled first if both present — actually order matters for event_type; add new block):

After the signature check and parse, add:
if event_type == "check_run":
  - action = payload.get("action")
  - if action != "completed": return {"status": "ignored", "reason": "check_not_completed"}
  - check_run = payload.get("check_run", {})
  - if check_run.get("name") != "booty/verifier": return {"status": "ignored"}
  - pull_requests = check_run.get("pull_requests", [])
  - if not pull_requests: return {"status": "ignored", "reason": "no_pr"}
  - Get pr_number from pull_requests[0] — structure may be {"number": N} or similar; verify payload shape
  - repo = payload.get("repository", {})
  - owner, repo_name = repo.get("owner",{}).get("login",""), repo.get("name","")
  - repo_full_name = repo.get("full_name","")
  - repo_url = repo.get("html_url","") or f"https://github.com/{repo_full_name}"
  - installation_id = payload.get("installation",{}).get("id") or 0
  - Load booty_config via _load_booty_config_for_repo(repo_url, settings.GITHUB_TOKEN)
  - mem_config = get_memory_config(booty_config) if booty_config else None
  - if not mem_config or not apply_memory_env_overrides(mem_config).enabled: return
  - if not mem_config.comment_on_pr: return
  - Get PR files: use get_verifier_repo or Github to get repo, pr = repo.get_pull(pr_number), paths = [f.filename for f in pr.get_files()]
  - surface_pr_comment(settings.GITHUB_TOKEN, repo_url, pr_number, paths, repo_full_name, mem_config)
  - return JSONResponse(202, {"status": "accepted", "event": "check_run", "memory_surfaced": True})
  - Wrap in try/except; on error log and return 500 or 202 with error status

Note: Use GitHub App token for get_verifier_repo if PR is in app-installed repo; or GITHUB_TOKEN. Check how Verifier/Security get repo — they use installation_id. For create_check_run we use get_verifier_repo(owner, repo_name, installation_id, settings). For PR files we need repo object. Use Github(settings.GITHUB_TOKEN).get_repo(repo_full_name) if GITHUB_TOKEN has repo access.
  </action>
  <verify>python -c "
# Structural: check_run branch exists
with open('src/booty/webhooks.py') as f:
    c = f.read()
assert 'check_run' in c
assert 'booty/verifier' in c
assert 'surface_pr_comment' in c
print('OK')
"</verify>
  <done>check_run handler surfaces memory on Verifier completion when PR and comment_on_pr</done>
</task>

<task type="auto">
  <name>Task 4: Tests</name>
  <files>tests/test_memory_surfacing.py</files>
  <action>
Create tests/test_memory_surfacing.py:
- format_matches_for_pr: empty list -> ""; single match formats correctly; multiple matches
- surface_pr_comment: when comment_on_pr False, does nothing (mock lookup.query)
- surface_pr_comment: when zero matches, does not call post_memory_comment (mock)
- surface_pr_comment: when matches, calls post_memory_comment with formatted body (mock)
  </action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -m pytest tests/test_memory_surfacing.py -v</verify>
  <done>Surfacing unit tests pass</done>
</task>

</tasks>

<verification>
- MEM-19: PR comment "Memory: related history" with marker on Verifier check completion
- MEM-20: Up to max_matches items (type, date, summary, link); configurable
- MEM-23: Informational only — no blocking
</verification>

<success_criteria>
- PR comment surfaces after Verifier completes when Memory enabled and comment_on_pr
- Zero matches → no comment
- Single updatable comment per PR
