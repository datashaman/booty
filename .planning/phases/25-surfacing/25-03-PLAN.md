---
phase: 25-surfacing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/github/issues.py
  - src/booty/memory/surfacing.py
  - src/booty/webhooks.py
  - tests/test_memory_surfacing.py
autonomous: true

must_haves:
  truths:
    - "On Observability incident issue creation: append 'Related history' section with up to 3 matches (MEM-22)"
    - "Placement: After Sentry link, before stack trace"
    - "When comment_on_incident_issue false: skip lookup entirely"
    - "Zero matches → omit section entirely"
    - "Format: longer than PR — include severity or extra context for triage"
  artifacts:
    - path: src/booty/github/issues.py
      provides: build_sentry_issue_body with related_history param
      contains: related_history
    - path: src/booty/memory/surfacing.py
      provides: build_related_history_for_incident
      contains: def build_related_history_for_incident
    - path: src/booty/webhooks.py
      provides: Observability path passes related_history to create
  key_links:
    - from: sentry_webhook
      to: memory.lookup.query
      via: build_related_history_for_incident
---

<objective>
Implement Observability incident issue surfacing: append "Related history" section to Sentry issue body when memory enabled and comment_on_incident_issue. Placement after Sentry link, before stack trace. MEM-22.

Purpose: Surface prior incidents (by path/fingerprint) when creating Observability issues for triage.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/25-surfacing/25-CONTEXT.md
@.planning/phases/25-surfacing/25-RESEARCH.md
@src/booty/github/issues.py
@src/booty/webhooks.py
@src/booty/memory/adapters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: build_sentry_issue_body — related_history param</name>
  <files>src/booty/github/issues.py</files>
  <action>
Modify build_sentry_issue_body(event: dict, web_url: str, related_history: str | None = None) -> str

- When related_history is not None and not empty: insert it after the Sentry link block, before "**Location:**"
- Current order: severity/env/release → first/last seen → Sentry link → [INSERT related_history HERE] → location → stack trace → breadcrumbs
- Format of related_history: caller provides full markdown (e.g. "**Related history:**\n\n- ...")
- Do not modify create_issue_from_sentry_event yet; it will be updated when caller passes related_history
  </action>
  <verify>python -c "
from booty.github.issues import build_sentry_issue_body
e = {'level':'error'}
b = build_sentry_issue_body(e, 'https://x', related_history='**Related history:**\n\n- x')
assert 'Related history' in b
assert '**Related history:**' in b
# Placement: related_history should appear before Location (which comes from culprit)
assert b.find('Related history') < b.find('**Location:**') or b.find('**Location:**') < 0
print('OK')
"</verify>
  <done>build_sentry_issue_body accepts and inserts related_history</done>
</task>

<task type="auto">
  <name>Task 2: build_related_history_for_incident in surfacing</name>
  <files>src/booty/memory/surfacing.py</files>
  <action>
Add to src/booty/memory/surfacing.py:

build_related_history_for_incident(
  event: dict,
  repo: str,
  mem_config: MemoryConfig,
  state_dir: Path | None = None,
) -> str
- If not mem_config.comment_on_incident_issue: return ""
- Derive paths from event: frames from exception.values[0].stacktrace.frames (filename), plus culprit, metadata.filename
- paths = [f.get("filename") for f in frames[-7:]] + [culprit, meta.get("filename")]; filter empty
- fingerprint: optional from event tags or metadata
- matches = lookup.query(paths=paths, repo=repo, fingerprint=fingerprint or None, config=mem_config, state_dir=state_dir)
- If not matches: return ""
- Format per match: "**{type}** ({date}) — {summary} — {links[0]} | severity: {severity}" (longer than PR per CONTEXT)
- Result subset may not have severity; get from full record if needed. lookup.result_subset returns type,timestamp,summary,links,id. Severity is in full record. For simplicity, pass severity through: modify lookup to include severity in result_subset when we need it for Observability. Or keep result_subset as-is and add optional include_severity param. Simplest: in build_related_history_for_incident, we only have result_subset. Omit severity if not in subset. Format: "- **{type}** ({date}) — {summary} — {link}"
- Return "**Related history:**\n\n" + "\n".join(formatted) or ""
  </action>
  <verify>python -c "
from booty.memory.surfacing import build_related_history_for_incident
assert callable(build_related_history_for_incident)
# With comment_on_incident_issue False, returns ""
print('OK')
"</verify>
  <done>build_related_history_for_incident derives paths, runs lookup, formats section</done>
</task>

<task type="auto">
  <name>Task 3: Wire Observability webhook to pass related_history</name>
  <files>src/booty/webhooks.py</files>
  <action>
In the Sentry webhook handler, BEFORE calling create_sentry_issue_with_retry:

1. Load booty_config via _load_booty_config_for_repo(settings.TARGET_REPO_URL, settings.GITHUB_TOKEN) — we may already load it for ingestion; do it once
2. mem_config = get_memory_config(booty_config) if booty_config else None
3. if mem_config: mem_config = apply_memory_env_overrides(mem_config)
4. related_history = ""
5. if mem_config and mem_config.enabled and mem_config.comment_on_incident_issue:
   - related_history = build_related_history_for_incident(event, _repo_from_url(settings.TARGET_REPO_URL), mem_config)
6. We need to pass related_history to create_sentry_issue_with_retry. That calls create_issue_from_sentry_event. Add param related_history to both:
   - create_issue_from_sentry_event(..., related_history: str | None = None)
   - create_sentry_issue_with_retry(..., related_history: str | None = None)
   - In create_issue_from_sentry_event: body = build_sentry_issue_body(event, web_url, related_history)
7. Call: create_sentry_issue_with_retry(event, ..., related_history=related_history)
  </action>
  <verify>python -c "
from booty.github.issues import create_issue_from_sentry_event
import inspect
sig = inspect.signature(create_issue_from_sentry_event)
assert 'related_history' in sig.parameters
print('OK')
"</verify>
  <done>Observability passes related_history; create_issue chain accepts it</done>
</task>

<task type="auto">
  <name>Task 4: Tests for incident surfacing</name>
  <files>tests/test_memory_surfacing.py</files>
  <action>
Add tests:
- build_related_history_for_incident: comment_on_incident_issue False -> ""
- build_related_history_for_incident: zero matches -> ""
- build_related_history_for_incident: with matches -> returns "**Related history:**" section
- build_sentry_issue_body with related_history inserts in correct position
  </action>
  <verify>cd /Users/marlinf/Projects/datashaman/booty && python -m pytest tests/test_memory_surfacing.py -v</verify>
  <done>Observability surfacing tests pass</done>
</task>

</tasks>

<verification>
- MEM-22: Observability incident issue includes "Related history" section with up to 3 matches
- Placement: after Sentry link, before stack trace
- comment_on_incident_issue false → no lookup, no section
- Zero matches → omit section

<success_criteria>
- Incident issues show related history when enabled
- Section format supports triage (type, date, summary, link)
