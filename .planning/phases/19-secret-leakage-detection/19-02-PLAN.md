---
phase: 19-secret-leakage-detection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/security/scanner.py
  - tests/test_security_scanner.py
autonomous: true

must_haves:
  truths:
    - "Secret scan runs on git diff output (changed files only)"
    - "Gitleaks preferred; trufflehog fallback when gitleaks missing"
    - "Findings converted to GitHub annotation format (path, start_line, end_line, message, title)"
    - "Annotations capped at 50; summary includes 'and N more' when truncated"
    - "Scanner failure (binary missing) returns clear error"
  artifacts:
    - path: src/booty/security/scanner.py
      provides: run_secret_scan, ScanResult, build_annotations
      contains: "run_secret_scan"
    - path: tests/test_security_scanner.py
      provides: Unit tests for scanner logic
      contains: "run_secret_scan"
  key_links:
    - from: scanner.run_secret_scan
      to: subprocess/git diff
      via: git diff base..head | gitleaks stdin
      pattern: "subprocess|git diff"
---

<objective>
Create security scanner module: run_secret_scan on diff, parse gitleaks/trufflehog output, build annotations (cap 50).

Purpose: SEC-03, SEC-04 — scan changed files, produce annotations for check failure.
Output: booty.security.scanner with run_secret_scan(workspace_path, base_sha, head_sha, config) -> ScanResult.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-secret-leakage-detection/19-CONTEXT.md
@.planning/phases/19-secret-leakage-detection/19-RESEARCH.md
@src/booty/security/job.py
@src/booty/github/checks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement run_secret_scan and ScanResult</name>
  <files>src/booty/security/scanner.py</files>
  <action>
Create src/booty/security/scanner.py:

1. ScanResult dataclass: findings (list of dict with path, start_line, rule_id, secret redacted), scan_ok (bool), error_message (str|None)

2. run_secret_scan(workspace_path: str, base_sha: str, head_sha: str, config: SecurityConfig | None) -> ScanResult:
   - Resolve scanner binary: config.secret_scanner if config else "gitleaks". Try that binary (shutil.which); if missing and gitleaks, try trufflehog; if both missing return ScanResult(scan_ok=False, error_message="Secret scanner not found")
   - Run: subprocess in workspace_path, command: git diff base_sha..head_sha piped to gitleaks stdin (or trufflehog equivalent)
   - For gitleaks: `git diff base_sha..head_sha | gitleaks stdin --report-format json --report-path=-` (v8 CLI). Exit code 0 = no findings, 1 = findings. Parse JSON from stdout.
   - For trufflehog: `trufflehog git file://. --since-commit base_sha` or similar; verify trufflehog diff-only syntax. If unclear, implement gitleaks first, trufflehog as stub returning "not implemented" until verified.
   - Empty diff (no changed files): return ScanResult(findings=[], scan_ok=True)
   - Parse JSON findings: extract File, StartLine, EndLine, RuleID, Secret (redact in message). Build list of finding dicts.
   - Return ScanResult(findings=..., scan_ok=True) or ScanResult(scan_ok=False, error_message=...) on crash
  </action>
  <verify>python -c "
from booty.security.scanner import run_secret_scan, ScanResult
# Smoke test: run in repo with no secrets (empty diff or clean)
r = run_secret_scan('.', 'HEAD^', 'HEAD', None)
assert hasattr(r, 'findings') and hasattr(r, 'scan_ok')
print('OK')
"</verify>
  <done>run_secret_scan executes, returns ScanResult with findings or error.</done>
</task>

<task type="auto">
  <name>Task 2: Implement build_annotations (cap 50)</name>
  <files>src/booty/security/scanner.py</files>
  <action>
Add build_annotations(findings: list, max_count: int = 50) -> tuple[list[dict], str]:
- Convert each finding to GitHub annotation: {path, start_line, end_line, annotation_level: "failure", message: "Secret detected: {rule_id}", title: "Secret detected"}
- Sort by: severity (if available) else by (path, start_line)
- Cap at max_count (50). If truncated, summary suffix: " and N more" where N = len(findings) - max_count
- Return (annotations, summary_suffix)
  </action>
  <verify>python -c "
from booty.security.scanner import build_annotations
a, s = build_annotations([], 50)
assert a == [] and s == ''
a2, s2 = build_annotations([{'path':'x', 'start_line':1, 'end_line':1, 'rule_id':'r'}], 50)
assert len(a2) == 1
assert a2[0]['annotation_level'] == 'failure'
print('OK')
"</verify>
  <done>build_annotations produces annotation dicts, caps at 50, returns summary suffix.</done>
</task>

<task type="auto">
  <name>Task 3: Add scanner tests</name>
  <files>tests/test_security_scanner.py</files>
  <action>
Add tests:
1. build_annotations with 0, 1, 51 findings — verify cap and "and N more"
2. run_secret_scan with missing binary — verify ScanResult.scan_ok=False, error_message set
3. run_secret_scan in clean dir (git diff with no secrets) — verify scan_ok=True, findings=[]
4. Optionally: mock subprocess for gitleaks JSON output, assert parsing
  </action>
  <verify>pytest tests/test_security_scanner.py -v</verify>
  <done>Scanner tests pass.</done>
</task>

</tasks>

<verification>
- run_secret_scan works with gitleaks installed; fallback when missing
- build_annotations format matches edit_check_run expectations (path, start_line, end_line, annotation_level, message, title)
- Cap 50 enforced
</verification>

<success_criteria>
- Scanner module complete
- Diff-based scan (base_sha..head_sha)
- Annotations compatible with GitHub Checks API
- Tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-secret-leakage-detection/19-02-SUMMARY.md`
</output>
