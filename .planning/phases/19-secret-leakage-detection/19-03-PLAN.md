---
phase: 19-secret-leakage-detection
plan: 03
type: execute
wave: 2
depends_on: ["01", "02"]
files_modified:
  - src/booty/security/runner.py
  - src/booty/security/job.py
  - src/booty/webhooks.py
autonomous: true

must_haves:
  truths:
    - "Security check FAILs when secret detected — title 'Security failed — secret detected'"
    - "Annotations appear on check run (file+line)"
    - "Empty diff skips scan, PASS"
    - "Scanner crash yields FAIL with clear message"
    - "Check completes in under 60 seconds (target)"
  artifacts:
    - path: src/booty/security/runner.py
      provides: process_security_job with secret scan integration
      contains: "run_secret_scan"
    - path: src/booty/security/job.py
      provides: SecurityJob with base_sha (or payload used)
  key_links:
    - from: runner.process_security_job
      to: scanner.run_secret_scan
      via: prepare workspace, run scan
      pattern: "run_secret_scan"
    - from: runner
      to: edit_check_run
      via: conclusion failure, output annotations
      pattern: "edit_check_run.*failure"
---

<objective>
Wire secret scanner into security runner: clone workspace, run scan, FAIL check with annotations on findings.

Purpose: SEC-03, SEC-04, SEC-17 — complete secret detection flow in booty/security check.
Output: process_security_job runs scan, FAILs with "Security failed — secret detected" + annotations when secrets found.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-secret-leakage-detection/19-CONTEXT.md
@.planning/phases/19-secret-leakage-detection/19-RESEARCH.md
@src/booty/security/runner.py
@src/booty/verifier/workspace.py
@src/booty/webhooks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add base_sha to SecurityJob and webhook</name>
  <files>src/booty/security/job.py, src/booty/webhooks.py</files>
  <action>
1. In SecurityJob (job.py): add base_sha: str field
2. In webhooks.py where SecurityJob is created: extract base_sha from payload["pull_request"]["base"]["sha"]; pass to SecurityJob
3. Handle missing base (fallback to empty string or skip Security enqueue if malformed payload — match existing pattern for head_sha)
  </action>
  <verify>python -c "
from booty.security.job import SecurityJob
j = SecurityJob(job_id='x', owner='o', repo_name='r', pr_number=1, head_sha='abc', head_ref='main', base_sha='base123', repo_url='u', installation_id=1, payload={})
assert j.base_sha == 'base123'
print('OK')
"</verify>
  <done>SecurityJob has base_sha; webhook populates it from PR payload.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate scanner into process_security_job</name>
  <files>src/booty/security/runner.py</files>
  <action>
In process_security_job, after loading security_config and before the Phase 18 "no scanners" early-exit:

1. Get base_sha from job.base_sha (or payload["pull_request"]["base"]["sha"] if job lacks it)
2. Use prepare_verification_workspace(repo_url, head_sha, token, head_ref) — reuse from verifier.workspace. Need GITHUB_TOKEN from settings for private repos.
3. Inside workspace context: call run_secret_scan(workspace.path, base_sha, head_sha, security_config)
4. If not scan_ok: edit_check_run(conclusion="failure", output={title: "Security failed — secret detected", summary: result.error_message or "Scan incomplete"})
5. If scan_ok and findings: build_annotations(findings, 50), edit_check_run(conclusion="failure", output={title: "Security failed — secret detected", summary: f"{len(findings)} secret(s) in N file(s)" + suffix, annotations: annotations})
6. If scan_ok and no findings: keep existing success path (edit_check_run conclusion="success")
7. Replace Phase 18 placeholder "no scanners configured" with this scan flow when security enabled
  </action>
  <verify>pytest tests/ -v -k "security" --ignore=tests/e2e/ 2>/dev/null | head -30</verify>
  <done>process_security_job runs scan, FAILs with annotations on secrets, PASS when clean.</done>
</task>

<task type="auto">
  <name>Task 3: Ensure workspace and timeout handling</name>
  <files>src/booty/security/runner.py</files>
  <action>
1. Import prepare_verification_workspace from booty.verifier.workspace
2. Pass settings.GITHUB_TOKEN (or equivalent) for private repo clone
3. Add try/except around workspace + scan: on timeout or exception, edit_check_run(conclusion="failure", output={title: "Security failed — secret detected", summary: "Scan incomplete: {error}"})
4. Empty diff: if base_sha == head_sha or git diff yields empty, run_secret_scan should return findings=[]; handle gracefully (PASS)
  </action>
  <verify>Read runner.py — ensure try/except and timeout/error paths call edit_check_run with failure</verify>
  <done>Errors and edge cases handled; check always completes.</done>
</task>

</tasks>

<verification>
- SEC-03: Changed files only (git diff base..head)
- SEC-04: FAIL + annotations + title "Security failed — secret detected"
- SEC-17: Diff-only keeps scan fast; 60s target (no hard timeout in plan — implement if needed)
</verification>

<success_criteria>
- Secret detected → check FAIL, annotations on file+line
- No secrets → check PASS
- Scanner/scanner missing → FAIL with clear message
- Check completes
</success_criteria>

<output>
After completion, create `.planning/phases/19-secret-leakage-detection/19-03-SUMMARY.md`
</output>
