# Phase 20: Dependency Vulnerability Gate - Research

**Researched:** 2026-02-16
**Domain:** Dependency vulnerability auditing, lockfile detection, multi-ecosystem CI gates
**Confidence:** HIGH

## Summary

Phase 20 requires auto-detecting ecosystems from lockfiles/manifests, running the appropriate audit tool per ecosystem, and FAILing the booty/security check when any vulnerability has severity >= HIGH. The project already has Phase 19 secret scanning wired; dependency audit runs in the same pipeline. CONTEXT.md locks decisions: Python (requirements*.txt, pyproject.toml, poetry.lock, Pipfile.lock, uv.lock), Node (package-lock.json, yarn.lock, pnpm-lock.yaml), PHP (composer.lock), Rust (Cargo.lock). All lockfiles must be audited; no short-circuiting; monorepos run parallel audits and deduplicate identical lockfiles by hash.

**Primary recommendation:** Use pip-audit (Python), npm/yarn/pnpm audit (Node), composer audit (PHP), cargo audit (Rust) with JSON output where available. Parse output for severity >= HIGH; pip-audit lacks native severity—treat all reported vulns as actionable or query OSV by ID for severity. Aggregate results, run audits in parallel, cap findings at 100 per CONTEXT.

## Standard Stack

### Core

| Tool | Version | Purpose | Why Standard |
|------|---------|---------|--------------|
| pip-audit | 2.x | Python dependency audit | Official PyPA, PyPI + OSV backends, `-f json` |
| npm audit | bundled | Node audit (package-lock.json) | Native to npm, `--json`, `--audit-level` |
| composer audit | 2.4+ | PHP dependency audit | Official Composer, `--format=json` |
| cargo audit | 0.22+ | Rust dependency audit | RustSec project, severity thresholds, JSON |

### Supporting

| Tool | Purpose | When to Use |
|------|---------|-------------|
| yarn audit | Node (yarn.lock) | When yarn.lock detected |
| pnpm audit | Node (pnpm-lock.yaml) | When pnpm-lock.yaml detected |

### Lockfile → Tool Mapping

| Lockfile/Manifest | Tool | Command pattern |
|-------------------|------|-----------------|
| requirements*.txt, pyproject.toml (no lock) | pip-audit | `pip-audit -r FILE` or `pip-audit .` |
| poetry.lock, Pipfile.lock, uv.lock | pip-audit | `pip-audit --locked .` (pyproject + pylock) |
| package-lock.json | npm audit | `npm audit --json` (from package dir) |
| yarn.lock | yarn audit | `yarn audit --json` |
| pnpm-lock.yaml | pnpm audit | `pnpm audit --json` |
| composer.lock | composer audit | `composer audit --format=json` |
| Cargo.lock | cargo audit | `cargo audit --format json` (or config) |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| pip-audit | Safety, pip-audit alternative | pip-audit is PyPA official; others less maintained |
| npm audit | Snyk, Dependabot | Native npm audit sufficient; no extra deps |

## Architecture Patterns

### Recommended Project Structure

```
src/booty/security/
├── scanner.py       # run_secret_scan (Phase 19)
├── audit.py         # NEW: lockfile detection, audit orchestration
├── runner.py        # process_security_job — add audit step after secret scan
└── job.py
```

### Pattern 1: Lockfile Discovery

**What:** Glob workspace for known lockfile/manifest patterns.
**When:** Before running any audit.
**Example:**

```python
LOCKFILE_PATTERNS = {
    "python": [
        "**/requirements*.txt", "**/pyproject.toml",
        "**/poetry.lock", "**/Pipfile.lock", "**/uv.lock",
    ],
    "node": ["**/package-lock.json", "**/yarn.lock", "**/pnpm-lock.yaml"],
    "php": ["**/composer.lock"],
    "rust": ["**/Cargo.lock"],
}
# Use pathspec or pathlib.rglob; dedupe by content hash for identical files.
```

### Pattern 2: Per-Ecosystem Audit Execution

**What:** Run subprocess for each unique lockfile, parse JSON, filter by severity.
**When:** After discovery; run in parallel (asyncio.gather or ThreadPoolExecutor).
**Example:**

```python
# pip-audit: exit 0=clean, 1=vulns. JSON: [{name, version, vulns: [{id, aliases, ...}]}]
# pip-audit vulns lack severity in JSON; treat all as actionable OR lookup OSV by ID
# npm audit --json: metadata.vulnerabilities.{critical,high,moderate,low}
# npm audit --audit-level=high: exit non-zero only if high/critical
```

### Pattern 3: Severity Filtering

**What:** FAIL only when severity >= fail_severity (default high).
**Tools:**
- **npm:** `--audit-level=high` or parse JSON `metadata.vulnerabilities`
- **cargo:** `--deny high` or config severity_threshold
- **composer:** No built-in severity filter; parse JSON, check severity field if present
- **pip-audit:** No severity in JSON; options: (a) treat all vulns as HIGH, or (b) OSV lookup by vuln ID for CVSS

**Recommendation:** For Phase 20 MVP, treat pip-audit vulns as HIGH when present (conservative). Add OSV severity lookup in future if needed.

### Anti-Patterns to Avoid

- **Short-circuit on first failure:** CONTEXT requires full blast radius; run all audits.
- **Skip pyproject.toml without lockfile:** CONTEXT: audit anyway; emit advisory "no lockfile present".
- **Block on single tool missing:** Fail that ecosystem with clear message; continue others.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Vulnerability DB | Custom CVE lookup | pip-audit, npm audit, etc. | Tools have maintained DBs |
| Lockfile parsing | Custom dependency graph | Audit tools read lockfiles | Tools do resolution + lookup |
| Severity mapping | Custom CVSS parser | Tool output or OSV API | Existing mappings |

## Common Pitfalls

### Pitfall 1: pip-audit No Severity in JSON
**What goes wrong:** pip-audit JSON vulns lack severity; can't filter low/medium.
**Why:** PyPA advisory DB doesn't expose severity in pip-audit output by default.
**How to avoid:** For fail_severity=high, treat any pip-audit vuln as failing (conservative). Or query OSV API with vuln ID for CVSS.
**Warning signs:** Assuming "severity" key in pip-audit JSON.

### Pitfall 2: Composer Exit Code Only Vulnerable vs Abandoned
**What goes wrong:** Exit 1=vulnerable, 2=abandoned, 3=both. No severity breakdown.
**How to avoid:** Parse JSON for per-advisory severity if available; else treat any vulnerable (exit 1 or 3) as HIGH when filtering.
**Warning signs:** Ignoring abandoned (exit 2) for SEC-07; we only care about vulns.

### Pitfall 3: Monorepo Duplicate Lockfiles
**What goes wrong:** Same lockfile content in multiple dirs (copied); audit N times.
**How to avoid:** Hash file content; dedupe before audit (CONTEXT).
**Warning signs:** Long runtimes in monorepos.

### Pitfall 4: Tool Not Installed
**What goes wrong:** subprocess fails; unclear error.
**How to avoid:** Check shutil.which(tool) before run; FAIL with "pip-audit not found — install to enable Python dependency audit".
**Warning signs:** Generic "audit failed" messages.

## Code Examples

### pip-audit JSON

```bash
pip-audit -r requirements.txt -f json
# Or for project: pip-audit .  or  pip-audit --locked .
# Output: [{"name":"pkg","version":"1.0","vulns":[{"id":"PYSEC-2024-123","aliases":["CVE-2024-12345"],...}]}]
```

### npm audit JSON

```bash
cd /path/to/package && npm audit --json
# metadata.vulnerabilities: { critical: N, high: N, moderate: N, low: N }
# npm audit --audit-level=high: exit 1 only when high or critical
```

### cargo audit

```bash
cargo audit -j 1  # single thread in workspace with Cargo.lock
# Config: audit.toml with severity_threshold = "high" for fail on high+
# Or: cargo audit exits 1 on any vuln; parse output for severity
```

### composer audit

```bash
composer audit --format=json --no-interaction
# Exit: 0=clean, 1=vulns, 2=abandoned, 3=both
# Parse JSON for advisory severity if present
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual CVE tracking | pip-audit, npm audit | 2020+ | Automated, maintained DBs |
| Exit-code only | JSON output | All major tools | Parse programmatically |
| Block whole check on one tool | Per-ecosystem fail | CONTEXT | Operators get full picture |

**Deprecated/outdated:**
- RetireJS (npm): npm audit native now
- safety (Python): pip-audit is PyPA successor

## Open Questions

1. **pip-audit severity**
   - What we know: JSON lacks severity; PyPI/OSV have it.
   - What's unclear: Whether to add OSV lookup for Phase 20.
   - Recommendation: Treat any pip-audit vuln as HIGH for Phase 20; revisit if too noisy.

2. **composer audit severity in JSON**
   - What we know: Composer 2.4+ has audit; --format=json.
   - What's unclear: Exact JSON schema for severity per advisory.
   - Recommendation: Parse JSON; if no severity field, treat all as HIGH when exit 1/3.

3. **Timeout (SEC-17: 60s)**
   - What we know: Secret scan + audit must fit 60s.
   - Recommendation: Run audits in parallel; set per-audit timeout (e.g. 30s each); cap total.

## Sources

### Primary (HIGH confidence)
- pip-audit GitHub README — exit codes, JSON format, usage
- npm docs — audit --json, --audit-level
- Composer changelog 2.4 — audit command
- rustsec/cargo-audit — severity, JSON

### Secondary (MEDIUM confidence)
- WebSearch: composer audit --format json
- WebSearch: cargo audit exit code severity

### Tertiary (LOW confidence)
- Stack Overflow: npm audit high only

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — official tools, well-documented
- Architecture: HIGH — subprocess + JSON parse, parallel execution
- Pitfalls: MEDIUM — pip-audit severity gap; composer schema

**Research date:** 2026-02-16
**Valid until:** 30 days (tools stable)
