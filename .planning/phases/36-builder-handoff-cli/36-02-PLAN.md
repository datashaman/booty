---
phase: 36-builder-handoff-cli
plan: 02
type: execute
wave: 2
depends_on: ['01']
files_modified:
  - src/booty/architect/artifact.py
  - src/booty/planner/store.py
  - src/booty/main.py
  - src/booty/webhooks.py
autonomous: true

must_haves:
  truths:
    - Builder consumes ArchitectPlan artifact first; falls back to Planner plan
    - Builder no longer triggers from agent:builder when Architect enabled
    - Webhook enqueues Builder only when Architect-approved artifact exists (or Planner completes in-process)
  artifacts:
    - path: src/booty/architect/artifact.py
      provides: load_architect_plan_for_issue
    - path: src/booty/planner/store.py
      provides: get_plan_for_builder (or equivalent resolution)
  key_links:
    - from: main.py process_job
      to: get_plan_for_builder
      via: plan resolution before process_issue_to_pr
      pattern: get_plan_for_builder|load_architect_plan_for_issue
---

<objective>
Builder handoff: consume ArchitectPlan artifact first, retire agent:builder trigger.

Purpose: ARCH-28 — Builder listens for Architect approval; consumes artifact from plans/{repo}/{issue}-architect.json; fallback to Planner plan with "unreviewed by Architect" marker; Builder no longer triggers from agent:builder. Webhook: when agent label, if Architect-approved plan exists → enqueue Builder; else enqueue Planner.
Output: get_plan_for_builder; Builder process_job uses it; webhook logic updated.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-builder-handoff-cli/36-RESEARCH.md
@.planning/phases/36-builder-handoff-cli/36-CONTEXT.md
@src/booty/main.py
@src/booty/webhooks.py
@src/booty/planner/store.py
</context>

<tasks>

<task type="auto">
  <name>Add load_architect_plan_for_issue to architect/artifact.py</name>
  <files>src/booty/architect/artifact.py</files>
  <action>
Add load_architect_plan_for_issue(owner, repo, issue_number, state_dir=None) -> ArchitectPlan | None.
- Read artifact path from architect_artifact_path; if not exists, return None.
- Parse JSON; reconstruct ArchitectPlan from dict (goal, steps, touch_paths, risk_level, handoff_to_builder, architect_notes, plan_version). Steps are list of dicts — use Step.model_validate. HandoffToBuilder.model_validate.
- Return ArchitectPlan or None on parse error.
</action>
  <verify>python -c "from booty.architect.artifact import load_architect_plan_for_issue; r = load_architect_plan_for_issue('x','y',999); assert r is None or isinstance(r, object)"</verify>
  <done>load_architect_plan_for_issue returns ArchitectPlan when file exists and valid, else None</done>
</task>

<task type="auto">
  <name>Add get_plan_for_builder and Builder consumption</name>
  <files>src/booty/planner/store.py, src/booty/main.py, src/booty/code_gen/generator.py</files>
  <action>
1. In planner/store.py (or architect/artifact.py): get_plan_for_builder(owner, repo, issue_number, github_token, state_dir) -> tuple[Plan | None, bool].
   - Try load_architect_plan_for_issue first. If found, convert ArchitectPlan to Plan: Plan(goal=ap.goal, steps=ap.steps, handoff_to_builder=ap.handoff_to_builder, touch_paths=ap.touch_paths, risk_level=ap.risk_level, plan_version="1", assumptions=[], constraints=[], tests=[], rollback=[], metadata={"source": "architect"}). Return (plan, False) for architect-reviewed.
   - Else get_plan_for_issue. If found, return (plan, True) for unreviewed-by-architect.
   - Else return (None, False).
2. In main.py process_job: replace get_plan_for_issue with get_plan_for_builder. Unpack (plan, unreviewed). Pass planner_plan=plan to process_issue_to_pr. If unreviewed, log "builder_using_planner_plan_unreviewed" for observability.
3. code_gen/generator._analysis_from_plan already accepts Plan. No change needed — we convert ArchitectPlan to Plan in get_plan_for_builder.
</action>
  <verify>grep -n "get_plan_for_builder\|load_architect_plan_for_issue" src/booty/main.py src/booty/planner/store.py</verify>
  <done>Builder uses architect artifact when present; fallback to Planner plan with unreviewed marker logged</done>
</task>

<task type="auto">
  <name>Update webhook: Builder trigger only from Architect approval</name>
  <files>src/booty/webhooks.py</files>
  <action>
In github_webhook, Builder trigger branch (agent label):
- Determine if Architect is enabled: load .booty.yml from repo, get_architect_config; architect_enabled = (architect_config and architect_config.enabled) when booty_config exists.
- When architect_enabled: do NOT enqueue Builder from agent label. Instead, if architect artifact exists for issue (load_architect_plan_for_issue returns not None) → enqueue Builder. Else → enqueue Planner (which will run Architect → Builder when done).
- When architect disabled or no architect config: keep current behavior (plan exists → Builder; no plan → Planner).
- Remove/retire the branch that enqueues Builder solely from agent:builder label when architect is enabled. The key: Builder is never triggered by agent label alone when architect enabled — only when we have Architect-approved artifact, or Planner worker completes (in-process enqueue).
</action>
  <verify>pytest tests/ -k webhook -v 2>/dev/null || true; read webhooks.py Builder branch logic</verify>
  <done>Webhook: architect enabled + agent label → Builder only if artifact exists, else Planner</done>
</task>

</tasks>

<verification>
- get_plan_for_builder tries architect artifact first
- process_job uses get_plan_for_builder
- Webhook respects architect_enabled; Builder from agent only when artifact exists
</verification>

<success_criteria>
- ARCH-28: Builder consumes ArchitectPlan artifact; no agent:builder trigger when architect enabled
- Fallback to Planner plan with unreviewed marker
</success_criteria>

<output>
After completion, create `.planning/phases/36-builder-handoff-cli/36-02-SUMMARY.md`
</output>
