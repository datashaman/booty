---
phase: 36-builder-handoff-cli
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/architect/artifact.py
  - src/booty/main.py
autonomous: true

must_haves:
  truths:
    - Architect persists approved ArchitectPlan to plans/owner/repo/{issue}-architect.json
    - Architect emits architect.plan.approved (structured log) when approved
  artifacts:
    - path: src/booty/architect/artifact.py
      provides: architect_artifact_path, save_architect_artifact
  key_links:
    - from: main.py _planner_worker_loop
      to: save_architect_artifact
      via: when arch_result.approved, after save_architect_result
      pattern: save_architect_artifact
---

<objective>
Persist ArchitectPlan artifact for Builder consumption and emit approval event.

Purpose: ARCH-26 — Architect persists approved artifact to ~/.booty/state/plans/&lt;repo&gt;/&lt;issue&gt;-architect.json. ARCH-27 — emit architect.plan.approved when approved. Builder will consume this artifact in Plan 02.
Output: architect/artifact.py with path + save; main.py calls save on approval and emits structured log.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-builder-handoff-cli/36-RESEARCH.md
@src/booty/architect/output.py
@src/booty/architect/cache.py
@src/booty/planner/store.py
</context>

<tasks>

<task type="auto">
  <name>Create architect/artifact.py with path and save</name>
  <files>src/booty/architect/artifact.py</files>
  <action>
Create src/booty/architect/artifact.py.
- architect_artifact_path(owner, repo, issue_number, state_dir=None) -> Path: returns state_dir/plans/owner/repo/{issue_number}-architect.json. Use get_planner_state_dir() from planner.store when state_dir is None.
- save_architect_artifact(owner, repo, issue_number, architect_plan, state_dir=None) -> Path: serialize ArchitectPlan to dict (goal, steps, touch_paths, risk_level, handoff_to_builder, architect_notes, plan_version). Use same atomic write pattern as planner/store.save_plan (tempfile + replace). ArchitectPlan is a plain class — extract attributes for JSON: goal, steps (model_dump each if needed), touch_paths, risk_level, handoff_to_builder (model_dump), architect_notes, plan_version.
- Include input_hash in artifact when available (for webhook staleness check in Plan 02). Accept optional input_hash param in save_architect_artifact.
</action>
  <verify>python -c "from booty.architect.artifact import architect_artifact_path, save_architect_artifact; from pathlib import Path; p = architect_artifact_path('o','r',1); assert 'plans' in str(p) and '1-architect.json' in str(p)"</verify>
  <done>architect_artifact_path and save_architect_artifact exist; path format matches plans/owner/repo/{issue}-architect.json</done>
</task>

<task type="auto">
  <name>Integrate artifact save and event emission in main.py</name>
  <files>src/booty/main.py</files>
  <action>
In _planner_worker_loop, when arch_result.approved (non-cache path):
1. After save_architect_result, call save_architect_artifact(job.owner, job.repo, job.issue_number, architect_plan, input_hash=result.normalized_input and hash if available). Pass architect_plan built from build_architect_plan. For input_hash: use a hash of result.normalized_input if we have it (e.g. from planner cache input_hash) — check process_planner_job return for normalized_input / input_hash. PlannerJobResult may have this; if not, we can add or leave input_hash empty for now.
2. Emit structured log: get_logger().info("architect_plan_approved", issue_number=job.issue_number, owner=job.owner, repo=job.repo, event="architect.plan.approved")
Also handle cache-hit approved path: when cached.approved and should_enqueue_builder, persist artifact from cached.plan too (so Builder can consume it). Build architect_plan from cached, then save_architect_artifact. Cache hit path doesn't have normalized_input readily — use None for input_hash.
</action>
  <verify>pytest tests/test_architect*.py -v 2>/dev/null || true; grep -r "save_architect_artifact\|architect_plan_approved" src/booty/main.py</verify>
  <done>Both approval paths (fresh + cache hit) persist artifact; structured log emitted on approval</done>
</task>

</tasks>

<verification>
- architect_artifact_path returns Path ending with {issue}-architect.json under plans/
- save_architect_artifact writes valid JSON with ArchitectPlan fields
- main.py approval branches call save_architect_artifact
- main.py logs architect_plan_approved
</verification>

<success_criteria>
- ARCH-26: Architect persists approved artifact
- ARCH-27: architect.plan.approved emitted (structured log)
- Artifact file created on every approval (fresh + cache hit)
</success_criteria>

<output>
After completion, create `.planning/phases/36-builder-handoff-cli/36-01-SUMMARY.md`
</output>
