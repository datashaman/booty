---
phase: 07-github-app-checks
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/booty/github/checks.py
  - src/booty/github/__init__.py
autonomous: true

must_haves:
  truths:
    - "check run named 'booty/verifier' can be created on a commit via App auth"
    - "create_check_run returns 201 and check is visible when using valid App credentials"
    - "Checks module uses GithubIntegration.get_github_for_installation only (no PAT)"
  artifacts:
    - path: src/booty/github/checks.py
      provides: create_check_run, get_verifier_repo (App auth)
      min_lines: 80
  key_links:
    - from: checks.py
      to: GithubIntegration
      via: get_github_for_installation(installation_id)
      pattern: GithubIntegration|get_github_for_installation
    - from: checks.py
      to: repo.create_check_run
      via: create_check_run(name="booty/verifier", ...)
      pattern: create_check_run
---

<objective>
Create booty/github/checks.py with create_check_run using GitHub App auth. Establishes the plumbing for booty/verifier check runs.

Purpose: VERIFY-01 — Checks API requires App token; repo.create_check_run() with App-authenticated Github instance.
Output: checks.py with create_check_run(owner, repo, head_sha, installation_id, ...) and helper to obtain App-authenticated repo.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-github-app-checks/07-RESEARCH.md
@.planning/phases/07-github-app-checks/07-CONTEXT.md
@src/booty/config.py
@src/booty/github/pulls.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checks.py with App auth and create_check_run</name>
  <files>src/booty/github/checks.py</files>
  <action>
Create src/booty/github/checks.py with:

1. get_verifier_repo(owner: str, repo_name: str, installation_id: int, settings: Settings) -> Repository | None
   - If not verifier_enabled(settings): return None
   - Normalize PEM: pk = settings.GITHUB_APP_PRIVATE_KEY.replace("\\n", "\n") if settings.GITHUB_APP_PRIVATE_KEY else ""
   - Use Auth.AppAuth(app_id=int(settings.GITHUB_APP_ID), private_key=pk)
   - gi = GithubIntegration(auth=auth)
   - g = gi.get_github_for_installation(installation_id)
   - return g.get_repo(f"{owner}/{repo_name}")
   - On AuthException/GithubException: log error with reason (auth_failed, bad_key, jwt_failed), re-raise or return None per CONTEXT "Log error and continue"
   - CONTEXT: "Misconfiguration: Log error and continue; include reason class"

2. create_check_run(owner, repo_name, head_sha, installation_id, settings, *, status="queued", output=None, details_url=None) -> CheckRun | None
   - repo = get_verifier_repo(owner, repo_name, installation_id, settings)
   - If repo is None: return None
   - output = output or {"title": "Booty Verifier", "summary": "Queued"}
   - check_run = repo.create_check_run(
         name="booty/verifier",  # exact per CONTEXT
         head_sha=head_sha,
         status=status,
         output=output,
         details_url=details_url,
     )
   - return check_run

3. Use booty.logging.get_logger()

4. Export in src/booty/github/__init__.py: add create_check_run, get_verifier_repo to __all__ or module exports
</action>
  <verify>
cd /Users/marlinf/Projects/datashaman/booty && python -c "
from booty.github.checks import create_check_run, get_verifier_repo
import inspect
# Verify signatures
sig = inspect.signature(create_check_run)
params = list(sig.parameters)
assert 'owner' in params and 'repo_name' in params and 'head_sha' in params and 'installation_id' in params and 'settings' in params
sig2 = inspect.signature(get_verifier_repo)
assert 'installation_id' in sig2.parameters
# Without real credentials, get_verifier_repo returns None
from booty.config import get_settings
s = get_settings()
if not (s.GITHUB_APP_ID and s.GITHUB_APP_PRIVATE_KEY):
    r = get_verifier_repo('owner', 'repo', 12345, s)
    assert r is None
print('OK: checks module has create_check_run, get_verifier_repo')
"
  </verify>
  <done>checks.py exists; create_check_run and get_verifier_repo use App auth; booty/verifier name; returns None when Verifier disabled.</done>
</task>

<task type="auto">
  <name>Task 2: Add edit_check_run helper for lifecycle</name>
  <files>src/booty/github/checks.py</files>
  <action>
Add to checks.py:

edit_check_run(check_run, *, status=None, conclusion=None, output=None) -> CheckRun
- Calls check_run.edit(status=status, conclusion=conclusion, output=output) with only non-None kwargs
- Used for queued → in_progress → completed transitions per CONTEXT
- Build kwargs dict: exclude None values, pass to check_run.edit(**kwargs)
- Return the check run (edit may return updated object)

Note: check_run.edit() is on PyGithub CheckRun. conclusion values: "success", "failure", "neutral", "cancelled", "skipped", "stale"
</action>
  <verify>
cd /Users/marlinf/Projects/datashaman/booty && python -c "
from booty.github.checks import edit_check_run
import inspect
sig = inspect.signature(edit_check_run)
assert 'check_run' in sig.parameters
assert 'status' in sig.parameters or 'conclusion' in sig.parameters
print('OK: edit_check_run exists')
"
  </verify>
  <done>edit_check_run helper for status/conclusion/output updates.</done>
</task>

</tasks>

<verification>
- checks.py creates CheckRun via repo.create_check_run with name "booty/verifier"
- Uses GithubIntegration.get_github_for_installation (App auth only)
- When verifier disabled, get_verifier_repo returns None, create_check_run returns None
</verification>

<success_criteria>
- [ ] checks.py with create_check_run, get_verifier_repo, edit_check_run
- [ ] All use GitHub App auth (no PAT)
- [ ] Check run name is "booty/verifier"
</success_criteria>

<output>
After completion, create `.planning/phases/07-github-app-checks/07-02-SUMMARY.md`
</output>
