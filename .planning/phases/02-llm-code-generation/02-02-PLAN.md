---
phase: 02-llm-code-generation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/code_gen/__init__.py
  - src/booty/code_gen/security.py
  - src/booty/code_gen/validator.py
autonomous: true

must_haves:
  truths:
    - "Path traversal attacks are blocked (../../etc/passwd rejected)"
    - "Restricted patterns (.github/workflows, .env) are denied"
    - "Syntactically invalid Python code is rejected before commit"
    - "Paths outside workspace root are rejected"
  artifacts:
    - path: "src/booty/code_gen/security.py"
      provides: "PathRestrictor class with canonical path resolution"
      exports: ["PathRestrictor"]
      min_lines: 30
    - path: "src/booty/code_gen/validator.py"
      provides: "Python syntax and import validation"
      exports: ["validate_python_syntax", "validate_generated_code"]
      min_lines: 20
  key_links:
    - from: "src/booty/code_gen/security.py"
      to: "pathspec"
      via: "PathSpec.from_lines for denylist matching"
      pattern: "pathspec\\.PathSpec"
    - from: "src/booty/code_gen/security.py"
      to: "pathlib"
      via: "resolve() + is_relative_to() for traversal prevention"
      pattern: "is_relative_to"
    - from: "src/booty/code_gen/validator.py"
      to: "ast"
      via: "ast.parse() for syntax validation"
      pattern: "ast\\.parse"
---

<objective>
Build the security and validation layer that gates all LLM-generated code before it touches the workspace.

Purpose: REQ-15 (path restrictions) and pre-commit validation prevent broken or dangerous code from reaching PRs.
Output: PathRestrictor for path security, syntax/import validators for code quality.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-llm-code-generation/02-RESEARCH.md
@.planning/phases/02-llm-code-generation/02-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Path restriction enforcement</name>
  <files>src/booty/code_gen/__init__.py, src/booty/code_gen/security.py</files>
  <action>
  1. Create src/booty/code_gen/__init__.py (empty package init).

  2. Create src/booty/code_gen/security.py with PathRestrictor class:

  ```
  class PathRestrictor:
      def __init__(self, workspace_root: Path, denylist_patterns: list[str]):
          - Store workspace_root.resolve() as self.workspace_root
          - Create pathspec.PathSpec.from_lines('gitwildmatch', denylist_patterns) as self.denylist

      def is_path_allowed(self, file_path: str) -> tuple[bool, str | None]:
          - Resolve (workspace_root / file_path).resolve()
          - Check is_relative_to(workspace_root) — reject if outside
          - Check denylist.match_file(relative_path) — reject if matches
          - Return (True, None) if allowed, (False, reason) if not

      @classmethod
      def from_config(cls, workspace_root: Path, restricted_paths_csv: str) -> "PathRestrictor":
          - Split CSV string into list of patterns
          - Return cls(workspace_root, patterns)

      def validate_all_paths(self, file_paths: list[str]) -> None:
          - Check each path, raise ValueError with details on first violation
  ```

  Use pathlib.Path for all path operations. Use pathspec for pattern matching (NOT fnmatch or regex).
  Handle OSError/RuntimeError from resolve() gracefully (reject the path).
  </action>
  <verify>
  Run a quick inline test:
  ```
  python -c "
  from pathlib import Path
  from booty.code_gen.security import PathRestrictor
  import tempfile, os
  d = tempfile.mkdtemp()
  r = PathRestrictor(Path(d), ['.github/workflows/**', '.env', '**/*.env'])
  assert r.is_path_allowed('src/app.py')[0] == True
  assert r.is_path_allowed('.github/workflows/ci.yml')[0] == False
  assert r.is_path_allowed('.env')[0] == False
  assert r.is_path_allowed('../../etc/passwd')[0] == False
  assert r.is_path_allowed('config/prod.env')[0] == False
  os.rmdir(d)
  print('ALL PASS')
  "
  ```
  </verify>
  <done>PathRestrictor blocks path traversal, restricted patterns, and paths outside workspace. from_config creates instance from CSV string.</done>
</task>

<task type="auto">
  <name>Task 2: Pre-commit code validation</name>
  <files>src/booty/code_gen/validator.py</files>
  <action>
  Create src/booty/code_gen/validator.py with these functions:

  1. **validate_python_syntax(filepath: Path, content: str) -> tuple[bool, str | None]**
     - Use ast.parse(content, filename=str(filepath))
     - Return (True, None) on success
     - Catch SyntaxError, return (False, f"Syntax error at line {e.lineno}: {e.msg}")

  2. **validate_generated_code(filepath: Path, content: str, workspace_root: Path) -> None**
     - Only validate .py files (skip non-Python files silently)
     - Call validate_python_syntax
     - Raise ValueError with details if validation fails
     - For non-.py files, just return (no validation needed)

  Keep it simple. Per RESEARCH.md open question #2, skip third-party import validation — CI will catch those. Only validate syntax.
  Do NOT import or depend on booty.config or booty.llm.models — this module should be standalone with stdlib imports only (ast, pathlib).
  </action>
  <verify>
  Run:
  ```
  python -c "
  from pathlib import Path
  from booty.code_gen.validator import validate_python_syntax, validate_generated_code
  ok, err = validate_python_syntax(Path('test.py'), 'x = 1\nprint(x)')
  assert ok and err is None
  bad, msg = validate_python_syntax(Path('test.py'), 'def foo(:\n  pass')
  assert not bad and msg is not None
  validate_generated_code(Path('test.js'), 'not python', Path('/tmp'))  # should not raise
  print('ALL PASS')
  "
  ```
  </verify>
  <done>validate_python_syntax catches syntax errors with line numbers. validate_generated_code gates .py files only, raises ValueError on invalid code.</done>
</task>

</tasks>

<verification>
- [ ] PathRestrictor blocks .github/workflows/**, .env, path traversal (../../), paths outside workspace
- [ ] PathRestrictor.from_config parses CSV denylist string
- [ ] validate_python_syntax returns (True, None) for valid Python
- [ ] validate_python_syntax returns (False, message) for invalid Python with line number
- [ ] validate_generated_code skips non-.py files
- [ ] No cross-dependencies on other Phase 2 modules
</verification>

<success_criteria>
Security and validation layer complete. All LLM-generated file paths can be checked against restrictions, and all generated Python code can be syntax-validated before commit.
</success_criteria>

<output>
After completion, create `.planning/phases/02-llm-code-generation/02-02-SUMMARY.md`
</output>
