---
phase: 29-plan-generation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/planner/risk.py
  - tests/test_planner_risk.py
autonomous: true

must_haves:
  truths:
    - risk_level HIGH when touch_paths include .github/workflows/**, infra/**, terraform/**, iam/**, deploy scripts, lockfiles, migrations
    - risk_level MEDIUM when touch_paths include dependency manifests (pyproject.toml, requirements*.txt, package.json, etc.)
    - risk_level LOW otherwise
    - risk_level and touch_paths align (advisory; Governor/Security enforce their own)
    - docs/README excluded from risk classification
    - Empty touch_paths → HIGH (unknown scope)
  artifacts:
    - path: src/booty/planner/risk.py
      provides: classify_risk_from_paths(touch_paths) -> tuple[risk_level, risk_drivers]
  key_links:
    - from: risk.py
      to: src/booty/release_governor/risk.py
      via: PathSpec.from_lines("gitwildmatch", patterns)
      pattern: PathSpec|match_file
---

<objective>
Create deterministic risk classification from touch_paths. Purely rules-based; LLM never overrides. Use PathSpec (project standard). Exclude docs/README from risk. Empty touch_paths → HIGH per CONTEXT.

Purpose: PLAN-09, PLAN-10, PLAN-11, PLAN-12 — risk_level derived from touch_paths.
Output: src/booty/planner/risk.py with classify_risk_from_paths.
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/29-plan-generation/29-CONTEXT.md
@.planning/phases/29-plan-generation/29-RESEARCH.md
@src/booty/release_governor/risk.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create classify_risk_from_paths</name>
  <files>src/booty/planner/risk.py</files>
  <action>
Create src/booty/planner/risk.py.

1. **Default patterns** (module-level constants):
   - HIGH_RISK_PATTERNS: [".github/workflows/**", "infra/**", "terraform/**", "iam/**", "**/migrations/**", "**/*lock*", "**/deploy*.sh", "**/deploy*.py"]
   - MEDIUM_RISK_PATTERNS: ["**/pyproject.toml", "**/requirements*.txt", "**/package.json", "**/Cargo.toml", "**/go.mod", "**/go.sum", "**/composer.json"]
   - EXCLUDE_FROM_RISK: ["docs/**", "README*", "*.md", "**/README*"] — per CONTEXT exclude docs/README

2. **classify_risk_from_paths(touch_paths: list[str]) -> tuple[Literal["LOW","MEDIUM","HIGH"], list[str]]**:
   - If touch_paths is empty or None → return ("HIGH", []) — CONTEXT: empty = unknown scope
   - Build PathSpec.from_lines("gitwildmatch", ...) for exclude, high, medium
   - For each path in touch_paths: skip if exclude matches (docs/README don't count toward risk)
   - If all paths excluded (nothing to check) → return ("LOW", [])
   - If any path matches high → return ("HIGH", list of matching paths)
   - If any path matches medium → max_risk = "MEDIUM", collect matching paths as drivers
   - Else → ("LOW", [])
   - Return (risk_level, risk_drivers)

3. Use typing.Literal, pathspec.PathSpec. Follow release_governor/risk.py pattern.
  </action>
  <verify>python -c "
from booty.planner.risk import classify_risk_from_paths
r, d = classify_risk_from_paths([])
assert r == 'HIGH' and d == []
r, d = classify_risk_from_paths(['src/foo.py'])
assert r == 'LOW'
r, d = classify_risk_from_paths(['.github/workflows/ci.yml'])
assert r == 'HIGH'
r, d = classify_risk_from_paths(['pyproject.toml'])
assert r == 'MEDIUM'
r, d = classify_risk_from_paths(['README.md'])
assert r == 'LOW'  # excluded
"</verify>
  <done>classify_risk_from_paths returns (risk_level, risk_drivers) per PLAN-09/10/11</done>
</task>

<task type="auto">
  <name>Task 2: Add planner risk tests</name>
  <files>tests/test_planner_risk.py</files>
  <action>
Create tests/test_planner_risk.py.

1. **test_empty_touch_paths_returns_high**: [] → HIGH, []
2. **test_high_risk_paths**: .github/workflows/**, infra/**, migrations, lockfiles → HIGH
3. **test_medium_risk_paths**: pyproject.toml, requirements.txt, package.json → MEDIUM
4. **test_low_risk_paths**: src/foo.py, tests/test_x.py → LOW
5. **test_excluded_from_risk**: docs/foo.md, README.md → not counted (LOW)
6. **test_highest_wins**: mix of high and medium paths → HIGH
7. **test_risk_drivers**: returned list contains paths that drove classification
  </action>
  <verify>pytest tests/test_planner_risk.py -v</verify>
  <done>Risk classification fully covered</done>
</task>

</tasks>

<verification>
- [ ] Empty touch_paths → HIGH
- [ ] HIGH patterns (workflows, infra, migrations, lockfiles) → HIGH
- [ ] MEDIUM patterns (manifests) → MEDIUM
- [ ] docs/README excluded
- [ ] Highest wins when mixed
</verification>
