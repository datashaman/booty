---
phase: 28-input-normalization
plan: 03
type: execute
wave: 3
depends_on: ["01", "02"]
files_modified:
  - src/booty/planner/worker.py
  - src/booty/cli.py
autonomous: true

must_haves:
  truths:
    - Webhook planner worker uses normalize_from_job; Plan built from PlannerInput.goal
    - booty plan --issue uses normalize_github_issue with full issue (title, body, labels)
    - booty plan --text uses normalize_cli_text; infers repo from cwd when in git repo
    - Optional repo context fetched for issue/CLI when repo + token available
  artifacts:
    - path: src/booty/planner/worker.py
      provides: process_planner_job consuming PlannerInput
    - path: src/booty/cli.py
      provides: plan_issue, plan_text consuming normalizers
  key_links:
    - from: worker.py
      to: planner.input.normalize_from_job
      via: process_planner_job(job) → inp = normalize_from_job(job, repo_context)
      pattern: normalize_from_job
    - from: cli.py plan_issue
      to: planner.input.normalize_github_issue
      via: Fetch issue, normalize, pass goal to Plan
      pattern: normalize_github_issue
    - from: cli.py plan_text
      to: planner.input.normalize_cli_text
      via: normalize_cli_text(text, repo_info)
      pattern: normalize_cli_text
---

<objective>
Wire planner worker and CLI to use input normalizers. Worker and CLI build Plan from PlannerInput.goal; optional repo context fetched when repo + GITHUB_TOKEN available. Full normalization pipeline operational.

Purpose: PLAN-01, PLAN-02, PLAN-03 — end-to-end flow; Phase 29 will consume full PlannerInput.
Output: worker and CLI use normalizers; Plan still minimal (Phase 29 does generation).
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-input-normalization/28-CONTEXT.md
@.planning/phases/28-input-normalization/28-RESEARCH.md
@src/booty/planner/worker.py
@src/booty/planner/input.py
@src/booty/cli.py
@src/booty/planner/jobs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire planner worker to normalizers</name>
  <files>src/booty/planner/worker.py</files>
  <action>
Update process_planner_job(job: PlannerJob):

1. Import normalize_from_job, get_repo_context from booty.planner.input
2. repo_context = None. If job.owner and job.repo and settings.GITHUB_TOKEN: repo_context = get_repo_context(job.owner, job.repo, settings.GITHUB_TOKEN)
3. inp = normalize_from_job(job, repo_context=repo_context)
4. goal = inp.goal (replace job.payload.get("issue", {}).get("title", "Untitled"))
5. handoff.commit_message_hint, pr_title = goal (unchanged)
6. Plan(goal=goal, ...) — rest unchanged. Worker still produces minimal plan; PlannerInput available for Phase 29 to consume fully.
  </action>
  <verify>Enqueue PlannerJob via webhook or test; worker runs without error, stores plan with goal from normalized input</verify>
  <done>Worker uses normalize_from_job; Plan built from PlannerInput.goal</done>
</task>

<task type="auto">
  <name>Task 2: Wire CLI plan --issue to normalizer</name>
  <files>src/booty/cli.py</files>
  <action>
Update plan_issue:

1. After fetching issue via gh_repo.get_issue(issue_number), build issue dict: {"title": issue.title, "body": issue.body or "", "labels": [{"name": l.name} for l in issue.get_labels()], "html_url": issue.html_url, "number": issue.number}
2. repo_info = {"owner": owner, "repo": repo_slug}
3. repo_context = get_repo_context(owner, repo_slug, token) if token else None
4. inp = normalize_github_issue(issue_dict, repo_info, repo_context)
5. goal = inp.goal (instead of issue.title)
6. Rest unchanged: Plan(goal=goal, ...), save_plan, etc.
  </action>
  <verify>booty plan issue 1 --repo owner/repo (with token) runs; plan has goal from issue title</verify>
  <done>plan_issue uses normalize_github_issue; full issue body and labels normalized</done>
</task>

<task type="auto">
  <name>Task 3: Wire CLI plan --text to normalizer</name>
  <files>src/booty/cli.py</files>
  <action>
Update plan_text:

1. repo_info = None. If --repo passed, parse to owner/repo. Else if in git repo: repo_info from _infer_repo_from_git(Path.cwd())
2. repo_context = get_repo_context(owner, repo, token) if repo_info and token else None
3. inp = normalize_cli_text(text, repo_info=repo_info, repo_context=repo_context)
4. goal = inp.goal; handoff fields = goal
5. Replace current logic (goal = text[:200]) with inp
6. plan_path_for_ad_hoc: keep using text for path (hash of input); or use inp.goal — RESEARCH says ad-hoc path. Current: plan_path_for_ad_hoc(text). Keep for uniqueness.
  </action>
  <verify>booty plan text "First line\nRest" produces plan with goal="First line"; booty plan text "Single" produces goal="Single"</verify>
  <done>plan_text uses normalize_cli_text; goal/body split; repo inferred from cwd when available</done>
</task>

</tasks>

<verification>
- Worker: process_planner_job with PlannerJob produces plan
- CLI: booty plan issue N, booty plan text "..." both use normalizers
- Optional repo context applied when repo + token available
</verification>

<success_criteria>
- Planner accepts GitHub issue (full payload) via webhook and CLI
- Planner accepts CLI free text
- Single normalized PlannerInput flows through; Phase 29 ready to consume
</success_criteria>

<output>
After completion, create .planning/phases/28-input-normalization/28-03-SUMMARY.md
</output>
