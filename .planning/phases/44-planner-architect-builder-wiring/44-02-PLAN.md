---
phase: 44-planner-architect-builder-wiring
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/architect/config.py
  - src/booty/architect/artifact.py
  - src/booty/test_runner/config.py
autonomous: true

must_haves:
  truths:
    - builder_compat defaults true (safe migration)
    - When compat=false, get_plan_for_builder returns (None, False) when no Architect artifact (no Planner fallback)
    - Config precedence: env overrides file; file over default (same as other Booty config)
  artifacts:
    - path: src/booty/architect/config.py
      provides: ArchitectConfig.builder_compat, apply_architect_env_overrides respects ARCHITECT_BUILDER_COMPAT
    - path: src/booty/architect/artifact.py
      provides: get_plan_for_builder(..., builder_compat: bool) — when False, no Planner fallback
  key_links:
    - from: src/booty/architect/artifact.py get_plan_for_builder
      to: ArchitectConfig.builder_compat
      via: caller passes compat from config
      pattern: builder_compat|get_plan_for_builder
---

<objective>
Add compat flag for Builder Planner fallback. WIRE-04: Builder consumes Architect artifact first; fallback to Planner plan only when compat enabled.

Purpose: Migration aid — repos can run Builder with Planner-only plans during rollout. Eventually compat=false enforces Architect-only.
Output: ArchitectConfig.builder_compat; get_plan_for_builder respects it
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-planner-architect-builder-wiring/44-CONTEXT.md
@.planning/phases/44-planner-architect-builder-wiring/44-RESEARCH.md
@src/booty/architect/config.py
@src/booty/architect/artifact.py
</context>

<tasks>

<task type="auto">
  <name>Add builder_compat to ArchitectConfig</name>
  <files>src/booty/architect/config.py, src/booty/test_runner/config.py</files>
  <action>
1. ArchitectConfig (architect/config.py): add builder_compat: bool = True
2. apply_architect_env_overrides: check ARCHITECT_BUILDER_COMPAT env (1/true/yes -> True; 0/false/no -> False); same pattern as ARCHITECT_ENABLED
3. test_runner/config.py BootyConfig.architect: raw dict — no change needed (ArchitectConfig validates). If architect block has builder_compat key, get_architect_config will validate it.
</action>
  <verify>python -c "from booty.architect.config import ArchitectConfig, apply_architect_env_overrides; c=ArchitectConfig(); assert c.builder_compat==True; c2=apply_architect_env_overrides(c); print('ok')"</verify>
  <done>ArchitectConfig has builder_compat default True; env ARCHITECT_BUILDER_COMPAT supported</done>
</task>

<task type="auto">
  <name>get_plan_for_builder respects compat</name>
  <files>src/booty/architect/artifact.py</files>
  <action>
Update get_plan_for_builder signature:
  get_plan_for_builder(owner, repo, issue_number, github_token=None, state_dir=None, builder_compat: bool = True)

Logic:
1. ap = load_architect_plan_for_issue(...); if ap: return (plan_from_ap, False)
2. If not builder_compat: return (None, False)  # no Planner fallback
3. plan = get_plan_for_issue(...); if plan: return (plan, True)
4. return (None, False)

Callers must pass builder_compat from architect config. main.py process_job and router _route_issues both call get_plan_for_builder — update to pass compat from get_architect_config (or True when architect disabled).
</action>
  <verify>python -c "
from booty.architect.artifact import get_plan_for_builder
p, u = get_plan_for_builder('x','y',999, builder_compat=False)
assert p is None and u is False
print('ok')
"</verify>
  <done>When builder_compat=False and no Architect artifact, get_plan_for_builder returns (None, False)</done>
</task>

<task type="auto">
  <name>Update get_plan_for_builder callers</name>
  <files>src/booty/main.py, src/booty/router/router.py</files>
  <action>
1. main.py process_job: before get_plan_for_builder, load booty_config, get architect_config, apply env overrides. builder_compat = architect_config.builder_compat if architect_config else True. Pass to get_plan_for_builder(..., builder_compat=builder_compat).

2. router/router.py _route_issues: already has architect_config. builder_compat = architect_config.builder_compat if architect_config else True. Pass to get_plan_for_builder(..., builder_compat=builder_compat).

Ensure architect disabled -> builder_compat=True (Architect skipped implies compat; Builder uses Planner plan directly).
</action>
  <verify>grep -n "get_plan_for_builder\|builder_compat" src/booty/main.py src/booty/router/router.py</verify>
  <done>Both callers pass builder_compat from config</done>
</task>

</tasks>

<verification>
- WIRE-04: Builder Planner fallback only when compat enabled
- compat default True preserves current behavior
- architect disabled -> compat True (Builder uses Planner plan)
</verification>

<success_criteria>
- ArchitectConfig.builder_compat = True default
- get_plan_for_builder(..., builder_compat=False) returns (None, False) when no Architect artifact
- main.py and router pass builder_compat from config
</success_criteria>

<output>
After completion, create .planning/phases/44-planner-architect-builder-wiring/44-02-SUMMARY.md
</output>
