---
phase: 44-planner-architect-builder-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/booty/architect/jobs.py
  - src/booty/main.py
autonomous: true

must_haves:
  truths:
    - Architect can be enqueued from webhook when plan exists but unreviewed
    - architect_is_duplicate(repo, plan_hash) prevents repeated Architect runs on same issue+plan
    - Architect worker processes ArchitectJob: load plan, run validation, enqueue Builder on approval
  artifacts:
    - path: src/booty/architect/jobs.py
      provides: ArchitectJob, architect_queue, architect_enqueue, architect_is_duplicate
      min_lines: 60
  key_links:
    - from: src/booty/main.py
      to: architect_queue
      via: _architect_worker_loop consuming ArchitectJob
      pattern: architect_enqueue|ArchitectJob
---

<objective>
Add Architect standalone enqueue path: ArchitectJob, architect_queue, architect worker. WIRE-02: when plan exists but unreviewed, webhook will enqueue Architect (Plan 03); this plan provides the queue and worker.

Purpose: Architect today runs only from Planner worker loop. Webhook-triggered Architect (e.g. user adds label to issue with existing plan) needs its own job type and worker.
Output: src/booty/architect/jobs.py; architect worker loop in main.py
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-planner-architect-builder-wiring/44-CONTEXT.md
@.planning/phases/44-planner-architect-builder-wiring/44-RESEARCH.md
@src/booty/planner/jobs.py
@src/booty/main.py
@src/booty/architect/artifact.py
</context>

<tasks>

<task type="auto">
  <name>Create architect/jobs.py</name>
  <files>src/booty/architect/jobs.py</files>
  <action>
Create src/booty/architect/jobs.py following planner/jobs.py pattern:

1. ArchitectJob dataclass: job_id, issue_number, issue_url, repo_url, owner, repo, payload, plan_hash (str)
   - plan_hash for dedup: (repo, plan_hash) per Phase 43

2. architect_queue: asyncio.Queue[ArchitectJob]

3. architect_processed: dict or set keyed by (repo_full_name, plan_hash) — use f"{repo}:{plan_hash}" for simplicity. Cap size (e.g. 1000); evict oldest.

4. architect_is_duplicate(repo_full_name: str, plan_hash: str) -> bool

5. architect_mark_processed(repo_full_name: str, plan_hash: str) -> None

6. architect_enqueue(job: ArchitectJob) -> bool — put on queue, return True; TimeoutError -> False

7. plan_hash: Router will pass plan_hash from architect.cache.architect_plan_hash(plan). ArchitectJob stores plan_hash for dedup; no local hash logic needed in jobs.py.
</action>
  <verify>python -c "from booty.architect.jobs import ArchitectJob, architect_enqueue, architect_is_duplicate; j=ArchitectJob('a',1,'','','o','r',{},'h'); print(architect_is_duplicate('o/r','h'))"</verify>
  <done>architect/jobs.py exists; ArchitectJob, architect_enqueue, architect_is_duplicate callable</done>
</task>

<task type="auto">
  <name>Add Architect worker loop in main.py</name>
  <files>src/booty/main.py</files>
  <action>
Add _architect_worker_loop in main.py lifespan (after planner worker setup):

1. Import: ArchitectJob, architect_enqueue, architect_queue, architect_is_duplicate, architect_mark_processed from booty.architect.jobs
2. Import: get_plan_for_issue from booty.planner.store; process_architect_input, ArchitectInput from architect
3. Loop: pop ArchitectJob from architect_queue
4. Load plan via get_plan_for_issue(owner, repo, issue_number, token)
5. If no plan: log architect_skip_no_plan, task_done, continue
6. Build ArchitectInput(plan=plan, normalized_input=None, repo_context=None, issue_metadata={issue_number})
7. Get architect_config from booty_config (load .booty.yml); apply_architect_env_overrides
8. arch_result = process_architect_input(architect_config, inp)
9. On approved: save_architect_artifact, architect_mark_processed(repo_full_name, plan_hash), enqueue Builder to job_queue (same Job shape as Planner→Builder), update comment, task_done
10. On block: post_architect_blocked_comment, add_architect_review_label, architect_mark_processed, task_done
11. On ArchitectConfigError: post_architect_invalid_config_comment, add_architect_review_label, task_done
12. Wire architect_queue to app.state; start _architect_worker_loop task; cancel on shutdown (mirror planner_worker_task)
</action>
  <verify>grep -n "architect_queue\|_architect_worker_loop\|ArchitectJob" src/booty/main.py | head -20</verify>
  <done>Architect worker processes jobs; approves -> enqueue Builder; blocks -> comment + label</done>
</task>

</tasks>

<verification>
- WIRE-02 enqueue path exists (router will call architect_enqueue in Plan 03)
- Architect dedup by (repo, plan_hash)
- Architect worker mirrors Planner→Architect inline flow (without Planner)
</verification>

<success_criteria>
- architect/jobs.py with ArchitectJob, architect_queue, architect_enqueue, architect_is_duplicate
- main.py _architect_worker_loop consumes jobs, runs process_architect_input, enqueues Builder on approval
- app lifecycle: architect worker started with planner, shut down on app stop
</success_criteria>

<output>
After completion, create .planning/phases/44-planner-architect-builder-wiring/44-01-SUMMARY.md
</output>
