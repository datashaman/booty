---
phase: 44-planner-architect-builder-wiring
plan: 03
type: execute
wave: 2
depends_on: ['44-01', '44-02']
files_modified:
  - src/booty/router/router.py
autonomous: true

must_haves:
  truths:
    - Plan-state-first routing: resolve plan before any enqueue; no "Planner first when should_run(planner)" branch
    - Architect-approved plan -> Builder enqueue only (WIRE-01)
    - Unreviewed plan -> Architect enqueue (WIRE-02)
    - No plan -> Planner enqueue (WIRE-03)
    - Disabled-agent behavior: Architect disabled + plan exists -> Builder; Planner disabled + no plan -> builder_blocked
  artifacts:
    - path: src/booty/router/router.py
      provides: plan-state-first _route_issues
  key_links:
    - from: src/booty/router/router.py _route_issues
      to: architect_enqueue
      via: when plan and unreviewed and architect_enabled
      pattern: architect_enqueue|ArchitectJob
---

<objective>
Rewrite router _route_issues to plan-state-first routing. WIRE-01, WIRE-02, WIRE-03.

Purpose: Current router enqueues Planner first when should_run(planner), ignoring plan state. Correct flow: resolve plan via get_plan_for_builder; Architect-approved -> Builder; unreviewed -> Architect; no plan -> Planner.
Output: router _route_issues with plan-state-first logic; Architect enqueue path
</objective>

<execution_context>
@/Users/marlinf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marlinf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/44-planner-architect-builder-wiring/44-CONTEXT.md
@.planning/phases/44-planner-architect-builder-wiring/44-RESEARCH.md
@src/booty/router/router.py
@src/booty/architect/jobs.py
</context>

<tasks>

<task type="auto">
  <name>Replace Planner-first with plan-state-first</name>
  <files>src/booty/router/router.py</files>
  <action>
Rewrite _route_issues flow:

1. After has_trigger_label check and "not_plan_or_builder_trigger" early return, do NOT check should_run(planner) first.

2. Resolve plan state early:
   - booty_config = load_booty_config_for_repo(...)
   - architect_config = get_architect_config(booty_config); apply_architect_env_overrides
   - architect_enabled = architect_config is not None and architect_config.enabled
   - builder_compat = architect_config.builder_compat if architect_config else True
   - plan, unreviewed = get_plan_for_builder(owner, repo, issue_number, github_token=..., builder_compat=builder_compat)

3. Plan-state-first routing (has_trigger_label is True at this point):
   - architect_enabled:
     - plan and not unreviewed -> route to Builder (skip to Builder enqueue block)
     - plan and unreviewed -> route to Architect: architect_is_duplicate(repo_full_name, plan_hash)? return already_processed. Else build ArchitectJob, architect_enqueue, return accepted
     - no plan -> route to Planner: should_run(planner)? planner_enqueue, return
   - not architect_enabled:
     - plan -> route to Builder
     - no plan -> route to Planner

4. For Architect path: need plan_hash. Compute via architect_plan_hash from architect/cache if it accepts Plan, or add hash_plan_json(plan) in architect/jobs. Planner plan: use get_plan_for_issue to get plan, then hash.

5. Planner path: existing planner_enqueue logic (delivery_id dedup, etc.)
6. Builder path: existing job_queue.enqueue logic (is_duplicate, has_issue_in_queue, etc.)
7. When no plan and should_run(planner) is False: post_builder_blocked_comment, return ignored
8. When no plan and should_run(planner): planner_enqueue, return accepted
</action>
  <verify>grep -n "get_plan_for_builder\|architect_enqueue\|plan_state\|unreviewed" src/booty/router/router.py | head -30</verify>
  <done>Router uses plan-state-first; Architect enqueue when unreviewed; Planner when no plan; Builder when approved</done>
</task>

<task type="auto">
  <name>Use architect_plan_hash for Architect dedup</name>
  <files>src/booty/router/router.py</files>
  <action>
Router needs plan_hash when enqueueing Architect. architect.cache.architect_plan_hash(plan) already exists and returns deterministic hash. When routing to Architect (plan and unreviewed), router has plan from get_plan_for_builder. Import architect_plan_hash from booty.architect.cache; plan_hash = architect_plan_hash(plan). Pass to ArchitectJob and architect_is_duplicate(repo_full_name, plan_hash).
</action>
  <verify>grep -n "architect_plan_hash\|ArchitectJob\|plan_hash" src/booty/router/router.py</verify>
  <done>Router uses architect_plan_hash when building ArchitectJob for dedup</done>
</task>

</tasks>

<verification>
- WIRE-01: Architect-approved -> Builder only
- WIRE-02: Unreviewed -> Architect (not Planner)
- WIRE-03: No plan -> Planner
- No "Planner first" branch; plan state drives routing
</verification>

<success_criteria>
- _route_issues resolves plan first
- Architect enqueue when plan exists, unreviewed, architect enabled
- Planner enqueue when no plan
- Builder enqueue when plan approved (or plan exists and architect disabled)
</success_criteria>

<output>
After completion, create .planning/phases/44-planner-architect-builder-wiring/44-03-SUMMARY.md
</output>
